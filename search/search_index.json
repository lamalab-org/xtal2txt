{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"xtal2txt documentation","text":"<p>xtal2txt is a package to </p> <ul> <li>convert crystal structures into text representations</li> <li>tokenize text representations </li> <li>convert text representations into crystal structures</li> </ul>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#text-representation","title":"Text representation","text":""},{"location":"api/#core-class","title":"Core class","text":""},{"location":"api/#xtal2txt.core.TextRep","title":"<code>TextRep</code>","text":"<p>Generate text representations of crystal structure for Language modelling.</p> <p>Attributes:</p> Name Type Description <code>structure</code> <p>pymatgen structure</p> <p>Methods:</p> Name Description <code>from_input </code> <p>a classmethod</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>class TextRep:\n    \"\"\"\n    Generate text representations of crystal structure for Language modelling.\n\n    Attributes:\n        structure : pymatgen structure\n\n    Methods:\n        from_input : a classmethod\n        get_cif_string(n=3)\n        get_parameters(n=3)\n        get_coords(name, n=3)\n        get_cartesian(n=3)\n        get_fractional(n=3)\n    \"\"\"\n\n    backend = InvCryRep()\n    condenser = StructureCondenser()\n    describer = StructureDescriber()\n\n    def __init__(\n        self,\n        structure: Structure,\n        transformations: List[Tuple[str, dict]] = None,\n    ) -&gt; None:\n        self.structure = structure\n        self.transformations = transformations or []\n        self.apply_transformations()\n\n    @classmethod\n    def from_input(\n        cls,\n        input_data: Union[str, Path, Structure],\n        transformations: List[Tuple[str, dict]] = None,\n    ) -&gt; \"TextRep\":\n        \"\"\"\n        Instantiate the TextRep class object with the pymatgen structure from a cif file, a cif string, or a pymatgen Structure object.\n\n        Args:\n            input_data (Union[str,pymatgen.core.structure.Structure]): A cif file of a crystal structure, a cif string,\n                or a pymatgen Structure object.\n\n        Returns:\n            TextRep: A TextRep object.\n        \"\"\"\n        if isinstance(input_data, Structure):\n            structure = input_data\n\n        elif isinstance(input_data, (str, Path)):\n            try:\n                if Path(input_data).is_file():\n                    structure = Structure.from_file(str(input_data))\n                else:\n                    raise ValueError\n            except (OSError, ValueError):\n                structure = Structure.from_str(str(input_data), \"cif\")\n\n        else:\n            structure = Structure.from_str(str(input_data), \"cif\")\n\n        return cls(structure, transformations)\n\n    def apply_transformations(self) -&gt; None:\n        \"\"\"\n        Apply transformations to the structure.\n        \"\"\"\n        for transformation, params in self.transformations:\n            transform_func = getattr(TransformationCallback, transformation)\n            self.structure = transform_func(self.structure, **params)\n\n    @staticmethod\n    def _safe_call(func, *args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception:\n            return None\n\n    @staticmethod\n    def round_numbers_in_string(original_string: str, decimal_places: int) -&gt; str:\n        \"\"\"\n        Rounds float numbers in the given string to the specified number of decimal places using regex.\n\n        Args:\n            original_string (str): The input string.\n            decimal_places (int): The number of decimal places to round to.\n\n        Returns:\n            str: The string with the float numbers rounded to the specified number of decimal places.\n        \"\"\"\n        pattern = r\"\\b\\d+\\.\\d+\\b\"\n        matches = re.findall(pattern, original_string)\n        rounded_numbers = [round(float(match), decimal_places) for match in matches]\n        new_string = re.sub(\n            pattern, lambda x: str(rounded_numbers.pop(0)), original_string\n        )\n        return new_string\n\n    def get_cif_string(\n        self, format: str = \"symmetrized\", decimal_places: int = 3\n    ) -&gt; str:\n        \"\"\"\n        Generate CIF as string in multi-line format.\n\n        All float numbers can be rounded to the specified number (decimal_places).\n        Currently supports two formats. Symmetrized (cif with symmetry operations and the least symmetric basis) ...\n        and P1 (conventional unit cell , with all the atoms listed and only identity as symmetry operation).\n\n        Args:\n            format (str): The format of the CIF file. Can be \"symmetrized\" or \"p1\".\n            decimal_places (int): The number of decimal places to round to.\n\n        Returns:\n            str: The CIF string.\n        \"\"\"\n\n        if format == \"symmetrized\":\n            symmetry_analyzer = SpacegroupAnalyzer(self.structure)\n            symmetrized_structure = symmetry_analyzer.get_symmetrized_structure()\n            cif_string = str(\n                CifWriter(\n                    symmetrized_structure,\n                    symprec=0.1,\n                    significant_figures=decimal_places,\n                ).cif_file\n            )\n            cif = \"\\n\".join(cif_string.split(\"\\n\")[1:])\n            return self.round_numbers_in_string(cif, decimal_places)\n\n        elif format == \"p1\":\n            cif_string = \"\\n\".join(self.structure.to(fmt=\"cif\").split(\"\\n\")[1:])\n            return self.round_numbers_in_string(cif_string, decimal_places)\n\n    def get_lattice_parameters(self, decimal_places: int = 3) -&gt; List[str]:\n        \"\"\"\n        Return lattice parameters of unit cells in a crystal lattice:\n        the lengths of the cell edges (a, b, and c) in angstrom and the angles between them (alpha, beta, and gamma) in degrees.\n\n        All float numbers can be rounded to a specific number (decimal_places).\n\n        Args:\n            decimal_places (int): The number of decimal places to round to.\n\n        Returns:\n            List[str]: The lattice parameters.\n        \"\"\"\n        return [\n            str(round(i, decimal_places)) for i in self.structure.lattice.parameters\n        ]\n\n    def get_coords(self, name: str = \"cartesian\", decimal_places: int = 3) -&gt; List[str]:\n        \"\"\"\n        Return list of atoms in unit cell for with their positions in Cartesian or fractional coordinates as per choice.\n\n        Args:\n            name (str): The name of the coordinates. Can be \"cartesian\" or \"fractional\".\n            decimal_places (int): The number of decimal places to round to.\n\n        Returns:\n            List[str]: The list of atoms with their positions.\n        \"\"\"\n        elements = []\n        for site in self.structure.sites:\n            elements.append(str(site.specie))\n            coord = [\n                str(x)\n                for x in (\n                    site.coords.round(decimal_places)\n                    if name == \"cartesian\"\n                    else site.frac_coords.round(decimal_places)\n                )\n            ]\n            elements.extend(coord)\n        return elements\n\n    def get_slices(self, primitive: bool = True) -&gt; str:\n        \"\"\"Returns SLICES representation of the crystal structure.\n        https://www.nature.com/articles/s41467-023-42870-7\n\n        Args:\n            primitive (bool): Whether to use the primitive structure or not.\n\n        Returns:\n            str: The SLICE representation of the crystal structure.\n        \"\"\"\n\n        if primitive:\n            primitive_structure = (\n                self.structure.get_primitive_structure()\n            )  # convert to primitive structure\n            return self.backend.structure2SLICES(primitive_structure)\n        return self.backend.structure2SLICES(self.structure)\n\n    def get_composition(self, format=\"hill\") -&gt; str:\n        \"\"\"Return composition in hill format.\n\n        Args:\n            format (str): format in which the composition is required.\n\n        Returns:\n            str: The composition in hill format.\n        \"\"\"\n        if format == \"hill\":\n            composition_string = self.structure.composition.hill_formula\n            composition = composition_string.replace(\" \", \"\")\n        return composition\n\n    def get_local_env_rep(self, local_env_kwargs: Optional[dict] = None) -&gt; str:\n        \"\"\"\n        Get the local environment representation of the crystal structure.\n\n        The local environment representation is a string that contains\n        the space group symbol and the local environment of each atom in the unit cell.\n        The local environment of each atom is represented as SMILES string and the\n        Wyckoff symbol of the local environment.\n\n        Args:\n            local_env_kwargs (dict): Keyword arguments to pass to the LocalEnvAnalyzer.\n\n        Returns:\n            str: The local environment representation of the crystal structure.\n        \"\"\"\n        if not local_env_kwargs:\n            local_env_kwargs = {}\n        analyzer = LocalEnvAnalyzer(**local_env_kwargs)\n        return analyzer.structure_to_local_env_string(self.structure)\n\n    def get_crystal_text_llm(\n        self,\n        permute_atoms: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Code adopted from https://github.com/facebookresearch/crystal-llm/blob/main/llama_finetune.py\n        https://openreview.net/pdf?id=0r5DE2ZSwJ\n\n        Returns the representation as per the above citation.\n\n        Args:\n            permute_atoms (bool): Whether to permute the atoms in the unit cell.\n\n        Returns:\n            str: The crystal-llm representation of the crystal structure.\n        \"\"\"\n\n        lengths = self.structure.lattice.parameters[:3]\n        angles = self.structure.lattice.parameters[3:]\n        atom_ids = self.structure.species\n        frac_coords = self.structure.frac_coords\n\n        if permute_atoms:\n            atom_coord_pairs = list(zip(atom_ids, frac_coords))\n            random.shuffle(atom_coord_pairs)\n            atom_ids, frac_coords = zip(*atom_coord_pairs)\n\n        crystal_str = (\n            \" \".join([\"{0:.1f}\".format(x) for x in lengths])\n            + \"\\n\"\n            + \" \".join([str(int(x)) for x in angles])\n            + \"\\n\"\n            + \"\\n\".join(\n                [\n                    str(t) + \"\\n\" + \" \".join([\"{0:.2f}\".format(x) for x in c])\n                    for t, c in zip(atom_ids, frac_coords)\n                ]\n            )\n        )\n\n        return crystal_str\n\n    def get_robocrys_rep(self):\n        \"\"\"\n        https://github.com/hackingmaterials/robocrystallographer/tree/main\n        \"\"\"\n\n        condensed_structure = self.condenser.condense_structure(self.structure)\n        return self.describer.describe(condensed_structure)\n\n    def get_wyckoff_positions(self):\n        \"\"\"\n        Getting wyckoff positions of the elements in the unit cell as the combination of...\n        number and letter.\n\n        Returns:\n            str:  A multi-line string that contain elements of the unit cell along with their wyckoff position in each line.\n\n        Hint:\n            At the end of the string, there is an additional newline character.\n        \"\"\"\n\n        spacegroup_analyzer = SpacegroupAnalyzer(self.structure)\n        wyckoff_sites = spacegroup_analyzer.get_symmetry_dataset()\n        element_symbols = [site.specie.element.symbol for site in self.structure.sites]\n\n        data = []\n\n        for i in range(len(wyckoff_sites[\"wyckoffs\"])):\n            sub_data = (\n                element_symbols[i],\n                wyckoff_sites[\"wyckoffs\"][i],\n                wyckoff_sites[\"equivalent_atoms\"][i],\n            )\n            data.append(sub_data)\n\n        a = dict(Counter(data))\n\n        output = \"\"\n        for i, j in a.items():\n            output += str(i[0]) + \" \" + str(j) + \" \" + str(i[1]) + \"\\n\"\n\n        return output\n\n    def get_wycryst(self):\n        \"\"\"\n        Obtaining the wyckoff representation for crystal structures that include:\n            chemical formula\n            space group number\n            elements of the unit cell with their wyckoff positions.\n\n        Returns:\n            str: A multi-line string that contains the chemical formula, space group number,\n                and the elements of the unit cell with their wyckoff positions.\n        \"\"\"\n        output = \"\"\n        chemical_formula = self.structure.composition.formula\n        output += chemical_formula\n        output += \"\\n\" + str(self.structure.get_space_group_info()[1])\n        output += \"\\n\" + self.get_wyckoff_positions()\n\n        return output\n\n    def get_atom_sequences_plusplus(\n        self, lattice_params: bool = False, decimal_places: int = 1\n    ) -&gt; str:\n        \"\"\"\n        Generating a string with the elements of composition inside the crystal lattice with the option to\n        get the lattice parameters as angles (int) and lengths (float) in a string with a space\n        between them\n\n        Args:\n            lattice_params (bool): Whether to include lattice parameters or not.\n            decimal_places (int): The number of decimal places to round to.\n\n        Returns:\n            str: The string representation of the crystal structure.\n        \"\"\"\n\n        try:\n            output = [site.specie.element.symbol for site in self.structure.sites]\n        except AttributeError:\n            output = [site.specie.symbol for site in self.structure.sites]\n        if lattice_params:\n            params = self.get_lattice_parameters(decimal_places=decimal_places)\n            params[3:] = [str(int(float(i))) for i in params[3:]]\n            output.extend(params)\n\n        return \" \".join(output)\n\n    def updated_zmatrix_rep(self, zmatrix, decimal_places=1):\n        \"\"\"\n        Replace the variables in the Z-matrix with their values and return the updated Z-matrix.\n        for eg: z-matrix from pymatgen\n        'N\\nN 1 B1\\nN 1 B2 2 A2\\nN 1 B3 2 A3 3 D3\\n\n        B1=3.79\n        B2=6.54\n        ....\n        is replaced to\n        'N\\nN 1 3.79\\nN 1 6.54 2 90\\nN 1 6.54 2 90 3 120\\n'\n\n        Args:\n            Zmatrix (bool): zmatrix multi line string as implemented in pymatgen.\n            decimal_places (int): The number of decimal places to round to.\n\n        Returns:\n            str: The updated Z-matrix representation of the crystal structure.\n        \"\"\"\n        lines = zmatrix.split(\"\\n\")\n        main_part = []\n        variables_part = []\n\n        # Determine the main part and the variables part of the Z-matrix\n        for line in lines:\n            if \"=\" in line:\n                variables_part.append(line)\n            else:\n                if line.strip():  # Skip empty lines\n                    main_part.append(line)\n\n        # Extract variables from the variables part\n        variable_dict = {}\n        for var_line in variables_part:\n            var, value = var_line.split(\"=\")\n            if var.startswith(\"B\"):\n                rounded_value = round(float(value.strip()), decimal_places)\n            else:\n                rounded_value = int(round(float(value.strip())))\n            variable_dict[var] = (\n                f\"{rounded_value}\"\n                if var.startswith((\"A\", \"D\"))\n                else f\"{rounded_value:.{decimal_places}f}\"\n            )\n\n        # Replace variables in the main part\n        replaced_lines = []\n        for line in main_part:\n            parts = line.split()\n            # atom = parts[0]\n            replaced_line = line\n            for i in range(1, len(parts)):\n                var = parts[i]\n                if var in variable_dict:\n                    replaced_line = replaced_line.replace(var, variable_dict[var])\n            replaced_lines.append(replaced_line)\n\n        return \"\\n\".join(replaced_lines)\n\n    def get_zmatrix_rep(self, decimal_places=1):\n        \"\"\"\n        Generate the Z-matrix representation of the crystal structure.\n        It provides a description of each atom in terms of its atomic number,\n        bond length, bond angle, and dihedral angle, the so-called internal coordinates.\n\n        Disclaimer: The Z-matrix is meant for molecules, current implementation converts atoms within unit cell to molecule.\n        Hence the current implentation might overlook bonds acrosse unit cells.\n        \"\"\"\n        species = [\n            s.element if hasattr(s, \"element\") else s for s in self.structure.species\n        ]\n        coords = [c for c in self.structure.cart_coords]\n        molecule_ = Molecule(\n            species,\n            coords,\n        )\n        zmatrix = molecule_.get_zmatrix()\n        return self.updated_zmatrix_rep(zmatrix, decimal_places)\n\n    def get_all_text_reps(self, decimal_places: int = 2):\n        \"\"\"\n        Returns all the Text representations of the crystal structure in a dictionary.\n        \"\"\"\n\n        return {\n            \"cif_p1\": self._safe_call(\n                self.get_cif_string, format=\"p1\", decimal_places=decimal_places\n            ),\n            \"cif_symmetrized\": self._safe_call(\n                self.get_cif_string, format=\"symmetrized\", decimal_places=decimal_places\n            ),\n            \"cif_bonding\": None,\n            \"slices\": self._safe_call(self.get_slices),\n            \"composition\": self._safe_call(self.get_composition),\n            \"crystal_text_llm\": self._safe_call(self.get_crystal_text_llm),\n            \"robocrys_rep\": self._safe_call(self.get_robocrys_rep),\n            \"wycoff_rep\": None,\n            \"atom_sequences\": self._safe_call(\n                self.get_atom_sequences_plusplus,\n                lattice_params=False,\n                decimal_places=decimal_places,\n            ),\n            \"atom_sequences_plusplus\": self._safe_call(\n                self.get_atom_sequences_plusplus,\n                lattice_params=True,\n                decimal_places=decimal_places,\n            ),\n            \"zmatrix\": self._safe_call(self.get_zmatrix_rep),\n            \"local_env\": self._safe_call(self.get_local_env_rep, local_env_kwargs=None),\n        }\n\n    def get_requested_text_reps(\n        self, requested_reps: List[str], decimal_places: int = 2\n    ):\n        \"\"\"\n        Returns the requested Text representations of the crystal structure in a dictionary.\n\n        Args:\n            requested_reps (List[str]): The list of representations to return.\n            decimal_places (int): The number of decimal places to round to.\n\n        Returns:\n            dict: A dictionary containing the requested text representations of the crystal structure.\n        \"\"\"\n\n        if requested_reps == \"cif_p1\":\n            return self._safe_call(\n                self.get_cif_string, format=\"p1\", decimal_places=decimal_places\n            )\n\n        elif requested_reps == \"cif_symmetrized\":\n            return self._safe_call(\n                self.get_cif_string,\n                format=\"symmetrized\",\n                decimal_places=decimal_places,\n            )\n\n        elif requested_reps == \"slices\":\n            return self._safe_call(self.get_slices)\n\n        elif requested_reps == \"composition\":\n            return self._safe_call(self.get_composition)\n\n        elif requested_reps == \"crystal_text_llm\":\n            return self._safe_call(self.get_crystal_text_llm)\n\n        elif requested_reps == \"robocrys_rep\":\n            return self._safe_call(self.get_robocrys_rep)\n\n        elif requested_reps == \"atom_sequences\":\n            return self._safe_call(\n                self.get_atom_sequences_plusplus,\n                lattice_params=False,\n                decimal_places=decimal_places,\n            )\n\n        elif requested_reps == \"atom_sequences_plusplus\":\n            return self._safe_call(\n                self.get_atom_sequences_plusplus,\n                lattice_params=True,\n                decimal_places=decimal_places,\n            )\n\n        elif requested_reps == \"zmatrix\":\n            return self._safe_call(self.get_zmatrix_rep)\n\n        elif requested_reps == \"local_env\":\n            return self._safe_call(self.get_local_env_rep, local_env_kwargs=None)\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.apply_transformations","title":"<code>apply_transformations()</code>","text":"<p>Apply transformations to the structure.</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>def apply_transformations(self) -&gt; None:\n    \"\"\"\n    Apply transformations to the structure.\n    \"\"\"\n    for transformation, params in self.transformations:\n        transform_func = getattr(TransformationCallback, transformation)\n        self.structure = transform_func(self.structure, **params)\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.from_input","title":"<code>from_input(input_data, transformations=None)</code>  <code>classmethod</code>","text":"<p>Instantiate the TextRep class object with the pymatgen structure from a cif file, a cif string, or a pymatgen Structure object.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>Union[str, Structure]</code> <p>A cif file of a crystal structure, a cif string, or a pymatgen Structure object.</p> required <p>Returns:</p> Name Type Description <code>TextRep</code> <code>TextRep</code> <p>A TextRep object.</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>@classmethod\ndef from_input(\n    cls,\n    input_data: Union[str, Path, Structure],\n    transformations: List[Tuple[str, dict]] = None,\n) -&gt; \"TextRep\":\n    \"\"\"\n    Instantiate the TextRep class object with the pymatgen structure from a cif file, a cif string, or a pymatgen Structure object.\n\n    Args:\n        input_data (Union[str,pymatgen.core.structure.Structure]): A cif file of a crystal structure, a cif string,\n            or a pymatgen Structure object.\n\n    Returns:\n        TextRep: A TextRep object.\n    \"\"\"\n    if isinstance(input_data, Structure):\n        structure = input_data\n\n    elif isinstance(input_data, (str, Path)):\n        try:\n            if Path(input_data).is_file():\n                structure = Structure.from_file(str(input_data))\n            else:\n                raise ValueError\n        except (OSError, ValueError):\n            structure = Structure.from_str(str(input_data), \"cif\")\n\n    else:\n        structure = Structure.from_str(str(input_data), \"cif\")\n\n    return cls(structure, transformations)\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.get_all_text_reps","title":"<code>get_all_text_reps(decimal_places=2)</code>","text":"<p>Returns all the Text representations of the crystal structure in a dictionary.</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>def get_all_text_reps(self, decimal_places: int = 2):\n    \"\"\"\n    Returns all the Text representations of the crystal structure in a dictionary.\n    \"\"\"\n\n    return {\n        \"cif_p1\": self._safe_call(\n            self.get_cif_string, format=\"p1\", decimal_places=decimal_places\n        ),\n        \"cif_symmetrized\": self._safe_call(\n            self.get_cif_string, format=\"symmetrized\", decimal_places=decimal_places\n        ),\n        \"cif_bonding\": None,\n        \"slices\": self._safe_call(self.get_slices),\n        \"composition\": self._safe_call(self.get_composition),\n        \"crystal_text_llm\": self._safe_call(self.get_crystal_text_llm),\n        \"robocrys_rep\": self._safe_call(self.get_robocrys_rep),\n        \"wycoff_rep\": None,\n        \"atom_sequences\": self._safe_call(\n            self.get_atom_sequences_plusplus,\n            lattice_params=False,\n            decimal_places=decimal_places,\n        ),\n        \"atom_sequences_plusplus\": self._safe_call(\n            self.get_atom_sequences_plusplus,\n            lattice_params=True,\n            decimal_places=decimal_places,\n        ),\n        \"zmatrix\": self._safe_call(self.get_zmatrix_rep),\n        \"local_env\": self._safe_call(self.get_local_env_rep, local_env_kwargs=None),\n    }\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.get_atom_sequences_plusplus","title":"<code>get_atom_sequences_plusplus(lattice_params=False, decimal_places=1)</code>","text":"<p>Generating a string with the elements of composition inside the crystal lattice with the option to get the lattice parameters as angles (int) and lengths (float) in a string with a space between them</p> <p>Parameters:</p> Name Type Description Default <code>lattice_params</code> <code>bool</code> <p>Whether to include lattice parameters or not.</p> <code>False</code> <code>decimal_places</code> <code>int</code> <p>The number of decimal places to round to.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string representation of the crystal structure.</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>def get_atom_sequences_plusplus(\n    self, lattice_params: bool = False, decimal_places: int = 1\n) -&gt; str:\n    \"\"\"\n    Generating a string with the elements of composition inside the crystal lattice with the option to\n    get the lattice parameters as angles (int) and lengths (float) in a string with a space\n    between them\n\n    Args:\n        lattice_params (bool): Whether to include lattice parameters or not.\n        decimal_places (int): The number of decimal places to round to.\n\n    Returns:\n        str: The string representation of the crystal structure.\n    \"\"\"\n\n    try:\n        output = [site.specie.element.symbol for site in self.structure.sites]\n    except AttributeError:\n        output = [site.specie.symbol for site in self.structure.sites]\n    if lattice_params:\n        params = self.get_lattice_parameters(decimal_places=decimal_places)\n        params[3:] = [str(int(float(i))) for i in params[3:]]\n        output.extend(params)\n\n    return \" \".join(output)\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.get_cif_string","title":"<code>get_cif_string(format='symmetrized', decimal_places=3)</code>","text":"<p>Generate CIF as string in multi-line format.</p> <p>All float numbers can be rounded to the specified number (decimal_places). Currently supports two formats. Symmetrized (cif with symmetry operations and the least symmetric basis) ... and P1 (conventional unit cell , with all the atoms listed and only identity as symmetry operation).</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str</code> <p>The format of the CIF file. Can be \"symmetrized\" or \"p1\".</p> <code>'symmetrized'</code> <code>decimal_places</code> <code>int</code> <p>The number of decimal places to round to.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The CIF string.</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>def get_cif_string(\n    self, format: str = \"symmetrized\", decimal_places: int = 3\n) -&gt; str:\n    \"\"\"\n    Generate CIF as string in multi-line format.\n\n    All float numbers can be rounded to the specified number (decimal_places).\n    Currently supports two formats. Symmetrized (cif with symmetry operations and the least symmetric basis) ...\n    and P1 (conventional unit cell , with all the atoms listed and only identity as symmetry operation).\n\n    Args:\n        format (str): The format of the CIF file. Can be \"symmetrized\" or \"p1\".\n        decimal_places (int): The number of decimal places to round to.\n\n    Returns:\n        str: The CIF string.\n    \"\"\"\n\n    if format == \"symmetrized\":\n        symmetry_analyzer = SpacegroupAnalyzer(self.structure)\n        symmetrized_structure = symmetry_analyzer.get_symmetrized_structure()\n        cif_string = str(\n            CifWriter(\n                symmetrized_structure,\n                symprec=0.1,\n                significant_figures=decimal_places,\n            ).cif_file\n        )\n        cif = \"\\n\".join(cif_string.split(\"\\n\")[1:])\n        return self.round_numbers_in_string(cif, decimal_places)\n\n    elif format == \"p1\":\n        cif_string = \"\\n\".join(self.structure.to(fmt=\"cif\").split(\"\\n\")[1:])\n        return self.round_numbers_in_string(cif_string, decimal_places)\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.get_composition","title":"<code>get_composition(format='hill')</code>","text":"<p>Return composition in hill format.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str</code> <p>format in which the composition is required.</p> <code>'hill'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The composition in hill format.</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>def get_composition(self, format=\"hill\") -&gt; str:\n    \"\"\"Return composition in hill format.\n\n    Args:\n        format (str): format in which the composition is required.\n\n    Returns:\n        str: The composition in hill format.\n    \"\"\"\n    if format == \"hill\":\n        composition_string = self.structure.composition.hill_formula\n        composition = composition_string.replace(\" \", \"\")\n    return composition\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.get_coords","title":"<code>get_coords(name='cartesian', decimal_places=3)</code>","text":"<p>Return list of atoms in unit cell for with their positions in Cartesian or fractional coordinates as per choice.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the coordinates. Can be \"cartesian\" or \"fractional\".</p> <code>'cartesian'</code> <code>decimal_places</code> <code>int</code> <p>The number of decimal places to round to.</p> <code>3</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: The list of atoms with their positions.</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>def get_coords(self, name: str = \"cartesian\", decimal_places: int = 3) -&gt; List[str]:\n    \"\"\"\n    Return list of atoms in unit cell for with their positions in Cartesian or fractional coordinates as per choice.\n\n    Args:\n        name (str): The name of the coordinates. Can be \"cartesian\" or \"fractional\".\n        decimal_places (int): The number of decimal places to round to.\n\n    Returns:\n        List[str]: The list of atoms with their positions.\n    \"\"\"\n    elements = []\n    for site in self.structure.sites:\n        elements.append(str(site.specie))\n        coord = [\n            str(x)\n            for x in (\n                site.coords.round(decimal_places)\n                if name == \"cartesian\"\n                else site.frac_coords.round(decimal_places)\n            )\n        ]\n        elements.extend(coord)\n    return elements\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.get_crystal_text_llm","title":"<code>get_crystal_text_llm(permute_atoms=False)</code>","text":"<p>Code adopted from https://github.com/facebookresearch/crystal-llm/blob/main/llama_finetune.py https://openreview.net/pdf?id=0r5DE2ZSwJ</p> <p>Returns the representation as per the above citation.</p> <p>Parameters:</p> Name Type Description Default <code>permute_atoms</code> <code>bool</code> <p>Whether to permute the atoms in the unit cell.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The crystal-llm representation of the crystal structure.</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>def get_crystal_text_llm(\n    self,\n    permute_atoms: bool = False,\n) -&gt; str:\n    \"\"\"\n    Code adopted from https://github.com/facebookresearch/crystal-llm/blob/main/llama_finetune.py\n    https://openreview.net/pdf?id=0r5DE2ZSwJ\n\n    Returns the representation as per the above citation.\n\n    Args:\n        permute_atoms (bool): Whether to permute the atoms in the unit cell.\n\n    Returns:\n        str: The crystal-llm representation of the crystal structure.\n    \"\"\"\n\n    lengths = self.structure.lattice.parameters[:3]\n    angles = self.structure.lattice.parameters[3:]\n    atom_ids = self.structure.species\n    frac_coords = self.structure.frac_coords\n\n    if permute_atoms:\n        atom_coord_pairs = list(zip(atom_ids, frac_coords))\n        random.shuffle(atom_coord_pairs)\n        atom_ids, frac_coords = zip(*atom_coord_pairs)\n\n    crystal_str = (\n        \" \".join([\"{0:.1f}\".format(x) for x in lengths])\n        + \"\\n\"\n        + \" \".join([str(int(x)) for x in angles])\n        + \"\\n\"\n        + \"\\n\".join(\n            [\n                str(t) + \"\\n\" + \" \".join([\"{0:.2f}\".format(x) for x in c])\n                for t, c in zip(atom_ids, frac_coords)\n            ]\n        )\n    )\n\n    return crystal_str\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.get_lattice_parameters","title":"<code>get_lattice_parameters(decimal_places=3)</code>","text":"<p>Return lattice parameters of unit cells in a crystal lattice: the lengths of the cell edges (a, b, and c) in angstrom and the angles between them (alpha, beta, and gamma) in degrees.</p> <p>All float numbers can be rounded to a specific number (decimal_places).</p> <p>Parameters:</p> Name Type Description Default <code>decimal_places</code> <code>int</code> <p>The number of decimal places to round to.</p> <code>3</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: The lattice parameters.</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>def get_lattice_parameters(self, decimal_places: int = 3) -&gt; List[str]:\n    \"\"\"\n    Return lattice parameters of unit cells in a crystal lattice:\n    the lengths of the cell edges (a, b, and c) in angstrom and the angles between them (alpha, beta, and gamma) in degrees.\n\n    All float numbers can be rounded to a specific number (decimal_places).\n\n    Args:\n        decimal_places (int): The number of decimal places to round to.\n\n    Returns:\n        List[str]: The lattice parameters.\n    \"\"\"\n    return [\n        str(round(i, decimal_places)) for i in self.structure.lattice.parameters\n    ]\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.get_local_env_rep","title":"<code>get_local_env_rep(local_env_kwargs=None)</code>","text":"<p>Get the local environment representation of the crystal structure.</p> <p>The local environment representation is a string that contains the space group symbol and the local environment of each atom in the unit cell. The local environment of each atom is represented as SMILES string and the Wyckoff symbol of the local environment.</p> <p>Parameters:</p> Name Type Description Default <code>local_env_kwargs</code> <code>dict</code> <p>Keyword arguments to pass to the LocalEnvAnalyzer.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The local environment representation of the crystal structure.</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>def get_local_env_rep(self, local_env_kwargs: Optional[dict] = None) -&gt; str:\n    \"\"\"\n    Get the local environment representation of the crystal structure.\n\n    The local environment representation is a string that contains\n    the space group symbol and the local environment of each atom in the unit cell.\n    The local environment of each atom is represented as SMILES string and the\n    Wyckoff symbol of the local environment.\n\n    Args:\n        local_env_kwargs (dict): Keyword arguments to pass to the LocalEnvAnalyzer.\n\n    Returns:\n        str: The local environment representation of the crystal structure.\n    \"\"\"\n    if not local_env_kwargs:\n        local_env_kwargs = {}\n    analyzer = LocalEnvAnalyzer(**local_env_kwargs)\n    return analyzer.structure_to_local_env_string(self.structure)\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.get_requested_text_reps","title":"<code>get_requested_text_reps(requested_reps, decimal_places=2)</code>","text":"<p>Returns the requested Text representations of the crystal structure in a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>requested_reps</code> <code>List[str]</code> <p>The list of representations to return.</p> required <code>decimal_places</code> <code>int</code> <p>The number of decimal places to round to.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the requested text representations of the crystal structure.</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>def get_requested_text_reps(\n    self, requested_reps: List[str], decimal_places: int = 2\n):\n    \"\"\"\n    Returns the requested Text representations of the crystal structure in a dictionary.\n\n    Args:\n        requested_reps (List[str]): The list of representations to return.\n        decimal_places (int): The number of decimal places to round to.\n\n    Returns:\n        dict: A dictionary containing the requested text representations of the crystal structure.\n    \"\"\"\n\n    if requested_reps == \"cif_p1\":\n        return self._safe_call(\n            self.get_cif_string, format=\"p1\", decimal_places=decimal_places\n        )\n\n    elif requested_reps == \"cif_symmetrized\":\n        return self._safe_call(\n            self.get_cif_string,\n            format=\"symmetrized\",\n            decimal_places=decimal_places,\n        )\n\n    elif requested_reps == \"slices\":\n        return self._safe_call(self.get_slices)\n\n    elif requested_reps == \"composition\":\n        return self._safe_call(self.get_composition)\n\n    elif requested_reps == \"crystal_text_llm\":\n        return self._safe_call(self.get_crystal_text_llm)\n\n    elif requested_reps == \"robocrys_rep\":\n        return self._safe_call(self.get_robocrys_rep)\n\n    elif requested_reps == \"atom_sequences\":\n        return self._safe_call(\n            self.get_atom_sequences_plusplus,\n            lattice_params=False,\n            decimal_places=decimal_places,\n        )\n\n    elif requested_reps == \"atom_sequences_plusplus\":\n        return self._safe_call(\n            self.get_atom_sequences_plusplus,\n            lattice_params=True,\n            decimal_places=decimal_places,\n        )\n\n    elif requested_reps == \"zmatrix\":\n        return self._safe_call(self.get_zmatrix_rep)\n\n    elif requested_reps == \"local_env\":\n        return self._safe_call(self.get_local_env_rep, local_env_kwargs=None)\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.get_robocrys_rep","title":"<code>get_robocrys_rep()</code>","text":"Source code in <code>src/xtal2txt/core.py</code> <pre><code>def get_robocrys_rep(self):\n    \"\"\"\n    https://github.com/hackingmaterials/robocrystallographer/tree/main\n    \"\"\"\n\n    condensed_structure = self.condenser.condense_structure(self.structure)\n    return self.describer.describe(condensed_structure)\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.get_slices","title":"<code>get_slices(primitive=True)</code>","text":"<p>Returns SLICES representation of the crystal structure. https://www.nature.com/articles/s41467-023-42870-7</p> <p>Parameters:</p> Name Type Description Default <code>primitive</code> <code>bool</code> <p>Whether to use the primitive structure or not.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The SLICE representation of the crystal structure.</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>def get_slices(self, primitive: bool = True) -&gt; str:\n    \"\"\"Returns SLICES representation of the crystal structure.\n    https://www.nature.com/articles/s41467-023-42870-7\n\n    Args:\n        primitive (bool): Whether to use the primitive structure or not.\n\n    Returns:\n        str: The SLICE representation of the crystal structure.\n    \"\"\"\n\n    if primitive:\n        primitive_structure = (\n            self.structure.get_primitive_structure()\n        )  # convert to primitive structure\n        return self.backend.structure2SLICES(primitive_structure)\n    return self.backend.structure2SLICES(self.structure)\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.get_wyckoff_positions","title":"<code>get_wyckoff_positions()</code>","text":"<p>Getting wyckoff positions of the elements in the unit cell as the combination of... number and letter.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>A multi-line string that contain elements of the unit cell along with their wyckoff position in each line.</p> Hint <p>At the end of the string, there is an additional newline character.</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>def get_wyckoff_positions(self):\n    \"\"\"\n    Getting wyckoff positions of the elements in the unit cell as the combination of...\n    number and letter.\n\n    Returns:\n        str:  A multi-line string that contain elements of the unit cell along with their wyckoff position in each line.\n\n    Hint:\n        At the end of the string, there is an additional newline character.\n    \"\"\"\n\n    spacegroup_analyzer = SpacegroupAnalyzer(self.structure)\n    wyckoff_sites = spacegroup_analyzer.get_symmetry_dataset()\n    element_symbols = [site.specie.element.symbol for site in self.structure.sites]\n\n    data = []\n\n    for i in range(len(wyckoff_sites[\"wyckoffs\"])):\n        sub_data = (\n            element_symbols[i],\n            wyckoff_sites[\"wyckoffs\"][i],\n            wyckoff_sites[\"equivalent_atoms\"][i],\n        )\n        data.append(sub_data)\n\n    a = dict(Counter(data))\n\n    output = \"\"\n    for i, j in a.items():\n        output += str(i[0]) + \" \" + str(j) + \" \" + str(i[1]) + \"\\n\"\n\n    return output\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.get_wycryst","title":"<code>get_wycryst()</code>","text":"Obtaining the wyckoff representation for crystal structures that include <p>chemical formula space group number elements of the unit cell with their wyckoff positions.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>A multi-line string that contains the chemical formula, space group number, and the elements of the unit cell with their wyckoff positions.</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>def get_wycryst(self):\n    \"\"\"\n    Obtaining the wyckoff representation for crystal structures that include:\n        chemical formula\n        space group number\n        elements of the unit cell with their wyckoff positions.\n\n    Returns:\n        str: A multi-line string that contains the chemical formula, space group number,\n            and the elements of the unit cell with their wyckoff positions.\n    \"\"\"\n    output = \"\"\n    chemical_formula = self.structure.composition.formula\n    output += chemical_formula\n    output += \"\\n\" + str(self.structure.get_space_group_info()[1])\n    output += \"\\n\" + self.get_wyckoff_positions()\n\n    return output\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.get_zmatrix_rep","title":"<code>get_zmatrix_rep(decimal_places=1)</code>","text":"<p>Generate the Z-matrix representation of the crystal structure. It provides a description of each atom in terms of its atomic number, bond length, bond angle, and dihedral angle, the so-called internal coordinates.</p> <p>Disclaimer: The Z-matrix is meant for molecules, current implementation converts atoms within unit cell to molecule. Hence the current implentation might overlook bonds acrosse unit cells.</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>def get_zmatrix_rep(self, decimal_places=1):\n    \"\"\"\n    Generate the Z-matrix representation of the crystal structure.\n    It provides a description of each atom in terms of its atomic number,\n    bond length, bond angle, and dihedral angle, the so-called internal coordinates.\n\n    Disclaimer: The Z-matrix is meant for molecules, current implementation converts atoms within unit cell to molecule.\n    Hence the current implentation might overlook bonds acrosse unit cells.\n    \"\"\"\n    species = [\n        s.element if hasattr(s, \"element\") else s for s in self.structure.species\n    ]\n    coords = [c for c in self.structure.cart_coords]\n    molecule_ = Molecule(\n        species,\n        coords,\n    )\n    zmatrix = molecule_.get_zmatrix()\n    return self.updated_zmatrix_rep(zmatrix, decimal_places)\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.round_numbers_in_string","title":"<code>round_numbers_in_string(original_string, decimal_places)</code>  <code>staticmethod</code>","text":"<p>Rounds float numbers in the given string to the specified number of decimal places using regex.</p> <p>Parameters:</p> Name Type Description Default <code>original_string</code> <code>str</code> <p>The input string.</p> required <code>decimal_places</code> <code>int</code> <p>The number of decimal places to round to.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string with the float numbers rounded to the specified number of decimal places.</p> Source code in <code>src/xtal2txt/core.py</code> <pre><code>@staticmethod\ndef round_numbers_in_string(original_string: str, decimal_places: int) -&gt; str:\n    \"\"\"\n    Rounds float numbers in the given string to the specified number of decimal places using regex.\n\n    Args:\n        original_string (str): The input string.\n        decimal_places (int): The number of decimal places to round to.\n\n    Returns:\n        str: The string with the float numbers rounded to the specified number of decimal places.\n    \"\"\"\n    pattern = r\"\\b\\d+\\.\\d+\\b\"\n    matches = re.findall(pattern, original_string)\n    rounded_numbers = [round(float(match), decimal_places) for match in matches]\n    new_string = re.sub(\n        pattern, lambda x: str(rounded_numbers.pop(0)), original_string\n    )\n    return new_string\n</code></pre>"},{"location":"api/#xtal2txt.core.TextRep.updated_zmatrix_rep","title":"<code>updated_zmatrix_rep(zmatrix, decimal_places=1)</code>","text":"<pre><code>    Replace the variables in the Z-matrix with their values and return the updated Z-matrix.\n    for eg: z-matrix from pymatgen\n    'N\n</code></pre> <p>N 1 B1 N 1 B2 2 A2 N 1 B3 2 A3 3 D3</p> <pre><code>    B1=3.79\n    B2=6.54\n    ....\n    is replaced to\n    'N\n</code></pre> <p>N 1 3.79 N 1 6.54 2 90 N 1 6.54 2 90 3 120 '</p> <pre><code>    Args:\n        Zmatrix (bool): zmatrix multi line string as implemented in pymatgen.\n        decimal_places (int): The number of decimal places to round to.\n\n    Returns:\n        str: The updated Z-matrix representation of the crystal structure.\n</code></pre> Source code in <code>src/xtal2txt/core.py</code> <pre><code>def updated_zmatrix_rep(self, zmatrix, decimal_places=1):\n    \"\"\"\n    Replace the variables in the Z-matrix with their values and return the updated Z-matrix.\n    for eg: z-matrix from pymatgen\n    'N\\nN 1 B1\\nN 1 B2 2 A2\\nN 1 B3 2 A3 3 D3\\n\n    B1=3.79\n    B2=6.54\n    ....\n    is replaced to\n    'N\\nN 1 3.79\\nN 1 6.54 2 90\\nN 1 6.54 2 90 3 120\\n'\n\n    Args:\n        Zmatrix (bool): zmatrix multi line string as implemented in pymatgen.\n        decimal_places (int): The number of decimal places to round to.\n\n    Returns:\n        str: The updated Z-matrix representation of the crystal structure.\n    \"\"\"\n    lines = zmatrix.split(\"\\n\")\n    main_part = []\n    variables_part = []\n\n    # Determine the main part and the variables part of the Z-matrix\n    for line in lines:\n        if \"=\" in line:\n            variables_part.append(line)\n        else:\n            if line.strip():  # Skip empty lines\n                main_part.append(line)\n\n    # Extract variables from the variables part\n    variable_dict = {}\n    for var_line in variables_part:\n        var, value = var_line.split(\"=\")\n        if var.startswith(\"B\"):\n            rounded_value = round(float(value.strip()), decimal_places)\n        else:\n            rounded_value = int(round(float(value.strip())))\n        variable_dict[var] = (\n            f\"{rounded_value}\"\n            if var.startswith((\"A\", \"D\"))\n            else f\"{rounded_value:.{decimal_places}f}\"\n        )\n\n    # Replace variables in the main part\n    replaced_lines = []\n    for line in main_part:\n        parts = line.split()\n        # atom = parts[0]\n        replaced_line = line\n        for i in range(1, len(parts)):\n            var = parts[i]\n            if var in variable_dict:\n                replaced_line = replaced_line.replace(var, variable_dict[var])\n        replaced_lines.append(replaced_line)\n\n    return \"\\n\".join(replaced_lines)\n</code></pre>"},{"location":"api/#decoding","title":"Decoding","text":""},{"location":"api/#xtal2txt.decoder.DecodeTextRep","title":"<code>DecodeTextRep</code>","text":"Source code in <code>src/xtal2txt/decoder.py</code> <pre><code>class DecodeTextRep:\n    def __init__(self, text):\n        self.text = text\n\n    def decode(self):\n        return self.text\n\n    def wyckoff_decoder(self, input: str, lattice_params: bool = False):\n        \"\"\"\n        Generating a pymatgen object from the output of the get_wyckoff_rep() method by using...\n        pyxtal package. In this method, all data are extracted from the multi-line string of the...\n        mentioned method.\n        In pyxtal package, a 3D crystal is produced by specifying the dimensions, elements,\n        composition of elements, space group, and sites as wyckoff positions of the elements.\n\n        Params:\n            lattice_params: boolean\n                To specify whether use lattice parameters in generating crystal structure.\n\n        Returns:\n            pmg_struc: pymatgen.core.structure.Structure\n        \"\"\"\n\n        # Always dimension is 3.\n        dimensions = 3\n\n        entities = input.split(\"\\n\")[:-1]\n        elements = entities[0]\n        spg = int(entities[1])\n        wyckoff_sites = entities[2:]\n        elements = elements.split(\" \")\n\n        atoms = []\n        composition = []\n        for el in elements:\n            atom = el.rstrip(\"0123456789\")\n            number = el[len(atom) :]\n            atoms.append(atom)\n            composition.append(int(number))\n\n        sites = []\n        for atom in atoms:\n            sub_site = []\n            for site in wyckoff_sites:\n                if atom in site:\n                    sub_site.append(site.split()[1])\n\n            sites.append(sub_site)\n\n        xtal_struc = pyxtal()\n\n        if lattice_params:\n            a, b, c, alpha, beta, gamma = self.get_lattice_parameters()\n            cell = pyLattice.from_para(\n                float(a), float(b), float(c), float(alpha), float(beta), float(gamma)\n            )\n            xtal_struc.from_random(dimensions, spg, atoms, composition, sites=sites, lattice=cell)\n        else:\n            xtal_struc.from_random(dimensions, spg, atoms, composition, sites=sites)\n\n        pmg_struc = xtal_struc.to_pymatgen()\n\n        return pmg_struc\n\n    def llm_decoder(self, input: str):\n        \"\"\"\n        Returning pymatgen structure out of multi-line representation.\n\n        Params:\n            input: str\n                String to obtain the items needed for the structure.\n\n        Returns:\n            pymatgen.core.structure.Structure\n        \"\"\"\n        entities = input.split(\"\\n\")\n        lengths = entities[0].split(\" \")\n        angles = entities[1].split(\" \")\n        lattice = Lattice.from_parameters(\n            a=float(lengths[0]),\n            b=float(lengths[1]),\n            c=float(lengths[2]),\n            alpha=float(angles[0]),\n            beta=float(angles[1]),\n            gamma=float(angles[2]),\n        )\n\n        elements = entities[2::2]\n        coordinates = entities[3::2]\n        m_coord = []\n        for i in coordinates:\n            s = [float(j) for j in i.split(\" \")]\n            m_coord.append(s)\n\n        return Structure(lattice, elements, m_coord)\n\n    def cif_string_decoder_p1(self, input: str):\n        \"\"\"\n        Returning a pymatgen structure out of a string format of a cif file.\n\n        Params:\n            input: str\n                String to obtain the items needed for the structure.\n\n        Returns:\n            pymatgen.core.structure.Structure\n        \"\"\"\n        entities = input.split(\"\\n\")[:-1]\n\n        params = []\n        for i in range(2, 8):\n            params.append(entities[i].split(\"   \")[1])\n\n        lattice = Lattice.from_parameters(\n            a=float(params[0]),\n            b=float(params[1]),\n            c=float(params[2]),\n            alpha=float(params[3]),\n            beta=float(params[4]),\n            gamma=float(params[5]),\n        )\n\n        elements = []\n        m_coord = []\n        atoms = entities[entities.index(\" _atom_site_occupancy\") + 1 :]\n        for atom in atoms:\n            ls = atom.split(\"  \")\n            elements.append(ls[1])\n            m_coord.append([float(ls[4]), float(ls[5]), float(ls[6])])\n\n        return Structure(lattice, elements, m_coord)\n\n    def cif_string_decoder_sym(self, input: str):\n        \"\"\"\n        Returning a pymatgen structure out of a string format of a symmetrized cif file.\n\n        Params:\n            input: str\n                String to obtain the items needed for the structure.\n\n        Returns:\n            pymatgen.core.structure.Structure\n        \"\"\"\n        entities = input.split(\"\\n\")[:-1]\n\n        params = []\n        for i in range(1, 8):\n            params.append(entities[i].split(\"   \")[1])\n\n        spg = params[0]\n        params = params[1:]\n        lattice = Lattice.from_parameters(\n            a=float(params[0]),\n            b=float(params[1]),\n            c=float(params[2]),\n            alpha=float(params[3]),\n            beta=float(params[4]),\n            gamma=float(params[5]),\n        )\n\n        elements = []\n        m_coord = []\n        atoms = entities[entities.index(\" _atom_site_occupancy\") + 1 :]\n        for atom in atoms:\n            ls = atom.split(\"  \")\n            elements.append(ls[1])\n            m_coord.append([float(ls[4]), float(ls[5]), float(ls[6])])\n\n        # print(atoms)\n\n        return Structure.from_spacegroup(spg, lattice, elements, m_coord)\n</code></pre>"},{"location":"api/#xtal2txt.decoder.DecodeTextRep.cif_string_decoder_p1","title":"<code>cif_string_decoder_p1(input)</code>","text":"<p>Returning a pymatgen structure out of a string format of a cif file.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str</code> <p>str String to obtain the items needed for the structure.</p> required <p>Returns:</p> Type Description <p>pymatgen.core.structure.Structure</p> Source code in <code>src/xtal2txt/decoder.py</code> <pre><code>def cif_string_decoder_p1(self, input: str):\n    \"\"\"\n    Returning a pymatgen structure out of a string format of a cif file.\n\n    Params:\n        input: str\n            String to obtain the items needed for the structure.\n\n    Returns:\n        pymatgen.core.structure.Structure\n    \"\"\"\n    entities = input.split(\"\\n\")[:-1]\n\n    params = []\n    for i in range(2, 8):\n        params.append(entities[i].split(\"   \")[1])\n\n    lattice = Lattice.from_parameters(\n        a=float(params[0]),\n        b=float(params[1]),\n        c=float(params[2]),\n        alpha=float(params[3]),\n        beta=float(params[4]),\n        gamma=float(params[5]),\n    )\n\n    elements = []\n    m_coord = []\n    atoms = entities[entities.index(\" _atom_site_occupancy\") + 1 :]\n    for atom in atoms:\n        ls = atom.split(\"  \")\n        elements.append(ls[1])\n        m_coord.append([float(ls[4]), float(ls[5]), float(ls[6])])\n\n    return Structure(lattice, elements, m_coord)\n</code></pre>"},{"location":"api/#xtal2txt.decoder.DecodeTextRep.cif_string_decoder_sym","title":"<code>cif_string_decoder_sym(input)</code>","text":"<p>Returning a pymatgen structure out of a string format of a symmetrized cif file.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str</code> <p>str String to obtain the items needed for the structure.</p> required <p>Returns:</p> Type Description <p>pymatgen.core.structure.Structure</p> Source code in <code>src/xtal2txt/decoder.py</code> <pre><code>def cif_string_decoder_sym(self, input: str):\n    \"\"\"\n    Returning a pymatgen structure out of a string format of a symmetrized cif file.\n\n    Params:\n        input: str\n            String to obtain the items needed for the structure.\n\n    Returns:\n        pymatgen.core.structure.Structure\n    \"\"\"\n    entities = input.split(\"\\n\")[:-1]\n\n    params = []\n    for i in range(1, 8):\n        params.append(entities[i].split(\"   \")[1])\n\n    spg = params[0]\n    params = params[1:]\n    lattice = Lattice.from_parameters(\n        a=float(params[0]),\n        b=float(params[1]),\n        c=float(params[2]),\n        alpha=float(params[3]),\n        beta=float(params[4]),\n        gamma=float(params[5]),\n    )\n\n    elements = []\n    m_coord = []\n    atoms = entities[entities.index(\" _atom_site_occupancy\") + 1 :]\n    for atom in atoms:\n        ls = atom.split(\"  \")\n        elements.append(ls[1])\n        m_coord.append([float(ls[4]), float(ls[5]), float(ls[6])])\n\n    # print(atoms)\n\n    return Structure.from_spacegroup(spg, lattice, elements, m_coord)\n</code></pre>"},{"location":"api/#xtal2txt.decoder.DecodeTextRep.llm_decoder","title":"<code>llm_decoder(input)</code>","text":"<p>Returning pymatgen structure out of multi-line representation.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str</code> <p>str String to obtain the items needed for the structure.</p> required <p>Returns:</p> Type Description <p>pymatgen.core.structure.Structure</p> Source code in <code>src/xtal2txt/decoder.py</code> <pre><code>def llm_decoder(self, input: str):\n    \"\"\"\n    Returning pymatgen structure out of multi-line representation.\n\n    Params:\n        input: str\n            String to obtain the items needed for the structure.\n\n    Returns:\n        pymatgen.core.structure.Structure\n    \"\"\"\n    entities = input.split(\"\\n\")\n    lengths = entities[0].split(\" \")\n    angles = entities[1].split(\" \")\n    lattice = Lattice.from_parameters(\n        a=float(lengths[0]),\n        b=float(lengths[1]),\n        c=float(lengths[2]),\n        alpha=float(angles[0]),\n        beta=float(angles[1]),\n        gamma=float(angles[2]),\n    )\n\n    elements = entities[2::2]\n    coordinates = entities[3::2]\n    m_coord = []\n    for i in coordinates:\n        s = [float(j) for j in i.split(\" \")]\n        m_coord.append(s)\n\n    return Structure(lattice, elements, m_coord)\n</code></pre>"},{"location":"api/#xtal2txt.decoder.DecodeTextRep.wyckoff_decoder","title":"<code>wyckoff_decoder(input, lattice_params=False)</code>","text":"<p>Generating a pymatgen object from the output of the get_wyckoff_rep() method by using... pyxtal package. In this method, all data are extracted from the multi-line string of the... mentioned method. In pyxtal package, a 3D crystal is produced by specifying the dimensions, elements, composition of elements, space group, and sites as wyckoff positions of the elements.</p> <p>Parameters:</p> Name Type Description Default <code>lattice_params</code> <code>bool</code> <p>boolean To specify whether use lattice parameters in generating crystal structure.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>pmg_struc</code> <p>pymatgen.core.structure.Structure</p> Source code in <code>src/xtal2txt/decoder.py</code> <pre><code>def wyckoff_decoder(self, input: str, lattice_params: bool = False):\n    \"\"\"\n    Generating a pymatgen object from the output of the get_wyckoff_rep() method by using...\n    pyxtal package. In this method, all data are extracted from the multi-line string of the...\n    mentioned method.\n    In pyxtal package, a 3D crystal is produced by specifying the dimensions, elements,\n    composition of elements, space group, and sites as wyckoff positions of the elements.\n\n    Params:\n        lattice_params: boolean\n            To specify whether use lattice parameters in generating crystal structure.\n\n    Returns:\n        pmg_struc: pymatgen.core.structure.Structure\n    \"\"\"\n\n    # Always dimension is 3.\n    dimensions = 3\n\n    entities = input.split(\"\\n\")[:-1]\n    elements = entities[0]\n    spg = int(entities[1])\n    wyckoff_sites = entities[2:]\n    elements = elements.split(\" \")\n\n    atoms = []\n    composition = []\n    for el in elements:\n        atom = el.rstrip(\"0123456789\")\n        number = el[len(atom) :]\n        atoms.append(atom)\n        composition.append(int(number))\n\n    sites = []\n    for atom in atoms:\n        sub_site = []\n        for site in wyckoff_sites:\n            if atom in site:\n                sub_site.append(site.split()[1])\n\n        sites.append(sub_site)\n\n    xtal_struc = pyxtal()\n\n    if lattice_params:\n        a, b, c, alpha, beta, gamma = self.get_lattice_parameters()\n        cell = pyLattice.from_para(\n            float(a), float(b), float(c), float(alpha), float(beta), float(gamma)\n        )\n        xtal_struc.from_random(dimensions, spg, atoms, composition, sites=sites, lattice=cell)\n    else:\n        xtal_struc.from_random(dimensions, spg, atoms, composition, sites=sites)\n\n    pmg_struc = xtal_struc.to_pymatgen()\n\n    return pmg_struc\n</code></pre>"},{"location":"api/#xtal2txt.decoder.MatchRep","title":"<code>MatchRep</code>","text":"Source code in <code>src/xtal2txt/decoder.py</code> <pre><code>class MatchRep:\n    def __init__(self, textrep, structure):\n        self.text = textrep\n        self.structure = structure\n\n    def wyckoff_matcher(\n        self,\n        ltol=0.2,\n        stol=0.5,\n        angle_tol=5,\n        primitive_cell=True,\n        scale=True,\n        allow_subset=True,\n        attempt_supercell=True,\n        lattice_params: bool = False,\n    ):\n        \"\"\"\n        To check if pymatgen object from the original cif file match with the generated...\n        pymatgen structure from wyckoff_decoder method out of wyckoff representation...\n        using fit() method of StructureMatcher module in pymatgen package.\n\n        Params:\n            StructureMatcher module can be access in below link with its parameters:\n                https://pymatgen.org/pymatgen.analysis.html#pymatgen.analysis.structure_matcher.StructureMatcher.get_mapping\n            lattice_params: bool\n                To specify using lattice parameters in the wyckoff_decoder method.\n\n        Returns:\n            StructureMatcher().fit_anonymous(): bool\n        \"\"\"\n\n        original_struct = self.structure\n\n        # output_struct = self.wyckoff_decoder(input, lattice_params)\n        output_struct = DecodeTextRep(self.text).wyckoff_decoder(self.text, lattice_params=True)\n\n        return StructureMatcher(\n            ltol,\n            stol,\n            angle_tol,\n            primitive_cell,\n            scale,\n            allow_subset,\n            attempt_supercell,\n        ).fit_anonymous(output_struct, original_struct)\n\n    def llm_matcher(\n        self,\n        ltol=0.2,\n        stol=0.5,\n        angle_tol=5,\n        primitive_cell=True,\n        scale=True,\n        allow_subset=True,\n        attempt_supercell=True,\n    ):\n        \"\"\"\n        To check if pymatgen object from the original cif file match with the generated\n        pymatgen structure from llm_decoder method out of llm representation\n        using fit() method of StructureMatcher module in pymatgen package.\n\n        Params:\n            input: str\n                String to obtain the items needed for the structure.\n\n            StructureMatcher module can be access in below link with its parameters:\n                https://pymatgen.org/pymatgen.analysis.html#pymatgen.analysis.structure_matcher.StructureMatcher.get_mapping\n\n        Returns:\n            StructureMatcher().fit(): bool\n        \"\"\"\n\n        original_struct = self.structure\n        output_struct = DecodeTextRep(self.text).llm_decoder(self.text)\n\n        return StructureMatcher(\n            ltol,\n            stol,\n            angle_tol,\n            primitive_cell,\n            scale,\n            allow_subset,\n            attempt_supercell,\n        ).fit(output_struct, original_struct)\n\n    def cif_string_matcher_sym(\n        self,\n        #        input: str,\n        ltol=0.2,\n        stol=0.5,\n        angle_tol=5,\n        primitive_cell=True,\n        scale=True,\n        allow_subset=True,\n        attempt_supercell=True,\n    ):\n        \"\"\"\n        To check if pymatgen object from the original cif file match with the generated\n        pymatgen structure from cif_string_decoder_sym method out of string cif representation.\n        using fit() method of StructureMatcher module in pymatgen package.\n\n        Params:\n            input: str\n                String to obtain the items needed for the structure.\n\n            StructureMatcher module can be access in below link with its parameters:\n                https://pymatgen.org/pymatgen.analysis.html#pymatgen.analysis.structure_matcher.StructureMatcher.get_mapping\n\n        Returns:\n            StructureMatcher().fit(): bool\n        \"\"\"\n\n        original_struct = self.structure\n        output_struct = DecodeTextRep(self.text).cif_string_decoder_sym(self.text)\n\n        return StructureMatcher(\n            ltol,\n            stol,\n            angle_tol,\n            primitive_cell,\n            scale,\n            allow_subset,\n            attempt_supercell,\n        ).fit(output_struct, original_struct)\n\n    def cif_string_matcher_p1(\n        self,\n        ltol=0.2,\n        stol=0.5,\n        angle_tol=5,\n        primitive_cell=True,\n        scale=True,\n        allow_subset=True,\n        attempt_supercell=True,\n    ):\n        \"\"\"\n        To check if pymatgen object from the original cif file match with the generated\n        pymatgen structure from cif_string_decoder_p1 method out of string cif representation\n        using fit() method of StructureMatcher module in pymatgen package.\n\n        Params:\n            input: str\n                String to obtain the items needed for the structure.\n\n            StructureMatcher module can be access in below link with its parameters:\n                https://pymatgen.org/pymatgen.analysis.html#pymatgen.analysis.structure_matcher.StructureMatcher.get_mapping\n\n        Returns:\n            StructureMatcher().fit(): bool\n        \"\"\"\n\n        original_struct = self.structure\n        output_struct = DecodeTextRep(self.text).cif_string_decoder_p1(self.text)\n\n        return StructureMatcher(\n            ltol,\n            stol,\n            angle_tol,\n            primitive_cell,\n            scale,\n            allow_subset,\n            attempt_supercell,\n        ).fit(output_struct, original_struct)\n</code></pre>"},{"location":"api/#xtal2txt.decoder.MatchRep.cif_string_matcher_p1","title":"<code>cif_string_matcher_p1(ltol=0.2, stol=0.5, angle_tol=5, primitive_cell=True, scale=True, allow_subset=True, attempt_supercell=True)</code>","text":"<p>To check if pymatgen object from the original cif file match with the generated pymatgen structure from cif_string_decoder_p1 method out of string cif representation using fit() method of StructureMatcher module in pymatgen package.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>str String to obtain the items needed for the structure.</p> required <code>StructureMatcher</code> <code>module can be access in below link with its parameters</code> <p>https://pymatgen.org/pymatgen.analysis.html#pymatgen.analysis.structure_matcher.StructureMatcher.get_mapping</p> required <p>Returns:</p> Name Type Description <code>StructureMatcher</code> <code>).fit(</code> <p>bool</p> Source code in <code>src/xtal2txt/decoder.py</code> <pre><code>def cif_string_matcher_p1(\n    self,\n    ltol=0.2,\n    stol=0.5,\n    angle_tol=5,\n    primitive_cell=True,\n    scale=True,\n    allow_subset=True,\n    attempt_supercell=True,\n):\n    \"\"\"\n    To check if pymatgen object from the original cif file match with the generated\n    pymatgen structure from cif_string_decoder_p1 method out of string cif representation\n    using fit() method of StructureMatcher module in pymatgen package.\n\n    Params:\n        input: str\n            String to obtain the items needed for the structure.\n\n        StructureMatcher module can be access in below link with its parameters:\n            https://pymatgen.org/pymatgen.analysis.html#pymatgen.analysis.structure_matcher.StructureMatcher.get_mapping\n\n    Returns:\n        StructureMatcher().fit(): bool\n    \"\"\"\n\n    original_struct = self.structure\n    output_struct = DecodeTextRep(self.text).cif_string_decoder_p1(self.text)\n\n    return StructureMatcher(\n        ltol,\n        stol,\n        angle_tol,\n        primitive_cell,\n        scale,\n        allow_subset,\n        attempt_supercell,\n    ).fit(output_struct, original_struct)\n</code></pre>"},{"location":"api/#xtal2txt.decoder.MatchRep.cif_string_matcher_sym","title":"<code>cif_string_matcher_sym(ltol=0.2, stol=0.5, angle_tol=5, primitive_cell=True, scale=True, allow_subset=True, attempt_supercell=True)</code>","text":"<p>To check if pymatgen object from the original cif file match with the generated pymatgen structure from cif_string_decoder_sym method out of string cif representation. using fit() method of StructureMatcher module in pymatgen package.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>str String to obtain the items needed for the structure.</p> required <code>StructureMatcher</code> <code>module can be access in below link with its parameters</code> <p>https://pymatgen.org/pymatgen.analysis.html#pymatgen.analysis.structure_matcher.StructureMatcher.get_mapping</p> required <p>Returns:</p> Name Type Description <code>StructureMatcher</code> <code>).fit(</code> <p>bool</p> Source code in <code>src/xtal2txt/decoder.py</code> <pre><code>def cif_string_matcher_sym(\n    self,\n    #        input: str,\n    ltol=0.2,\n    stol=0.5,\n    angle_tol=5,\n    primitive_cell=True,\n    scale=True,\n    allow_subset=True,\n    attempt_supercell=True,\n):\n    \"\"\"\n    To check if pymatgen object from the original cif file match with the generated\n    pymatgen structure from cif_string_decoder_sym method out of string cif representation.\n    using fit() method of StructureMatcher module in pymatgen package.\n\n    Params:\n        input: str\n            String to obtain the items needed for the structure.\n\n        StructureMatcher module can be access in below link with its parameters:\n            https://pymatgen.org/pymatgen.analysis.html#pymatgen.analysis.structure_matcher.StructureMatcher.get_mapping\n\n    Returns:\n        StructureMatcher().fit(): bool\n    \"\"\"\n\n    original_struct = self.structure\n    output_struct = DecodeTextRep(self.text).cif_string_decoder_sym(self.text)\n\n    return StructureMatcher(\n        ltol,\n        stol,\n        angle_tol,\n        primitive_cell,\n        scale,\n        allow_subset,\n        attempt_supercell,\n    ).fit(output_struct, original_struct)\n</code></pre>"},{"location":"api/#xtal2txt.decoder.MatchRep.llm_matcher","title":"<code>llm_matcher(ltol=0.2, stol=0.5, angle_tol=5, primitive_cell=True, scale=True, allow_subset=True, attempt_supercell=True)</code>","text":"<p>To check if pymatgen object from the original cif file match with the generated pymatgen structure from llm_decoder method out of llm representation using fit() method of StructureMatcher module in pymatgen package.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>str String to obtain the items needed for the structure.</p> required <code>StructureMatcher</code> <code>module can be access in below link with its parameters</code> <p>https://pymatgen.org/pymatgen.analysis.html#pymatgen.analysis.structure_matcher.StructureMatcher.get_mapping</p> required <p>Returns:</p> Name Type Description <code>StructureMatcher</code> <code>).fit(</code> <p>bool</p> Source code in <code>src/xtal2txt/decoder.py</code> <pre><code>def llm_matcher(\n    self,\n    ltol=0.2,\n    stol=0.5,\n    angle_tol=5,\n    primitive_cell=True,\n    scale=True,\n    allow_subset=True,\n    attempt_supercell=True,\n):\n    \"\"\"\n    To check if pymatgen object from the original cif file match with the generated\n    pymatgen structure from llm_decoder method out of llm representation\n    using fit() method of StructureMatcher module in pymatgen package.\n\n    Params:\n        input: str\n            String to obtain the items needed for the structure.\n\n        StructureMatcher module can be access in below link with its parameters:\n            https://pymatgen.org/pymatgen.analysis.html#pymatgen.analysis.structure_matcher.StructureMatcher.get_mapping\n\n    Returns:\n        StructureMatcher().fit(): bool\n    \"\"\"\n\n    original_struct = self.structure\n    output_struct = DecodeTextRep(self.text).llm_decoder(self.text)\n\n    return StructureMatcher(\n        ltol,\n        stol,\n        angle_tol,\n        primitive_cell,\n        scale,\n        allow_subset,\n        attempt_supercell,\n    ).fit(output_struct, original_struct)\n</code></pre>"},{"location":"api/#xtal2txt.decoder.MatchRep.wyckoff_matcher","title":"<code>wyckoff_matcher(ltol=0.2, stol=0.5, angle_tol=5, primitive_cell=True, scale=True, allow_subset=True, attempt_supercell=True, lattice_params=False)</code>","text":"<p>To check if pymatgen object from the original cif file match with the generated... pymatgen structure from wyckoff_decoder method out of wyckoff representation... using fit() method of StructureMatcher module in pymatgen package.</p> <p>Parameters:</p> Name Type Description Default <code>StructureMatcher</code> <code>module can be access in below link with its parameters</code> <p>https://pymatgen.org/pymatgen.analysis.html#pymatgen.analysis.structure_matcher.StructureMatcher.get_mapping</p> required <code>lattice_params</code> <code>bool</code> <p>bool To specify using lattice parameters in the wyckoff_decoder method.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>StructureMatcher</code> <code>).fit_anonymous(</code> <p>bool</p> Source code in <code>src/xtal2txt/decoder.py</code> <pre><code>def wyckoff_matcher(\n    self,\n    ltol=0.2,\n    stol=0.5,\n    angle_tol=5,\n    primitive_cell=True,\n    scale=True,\n    allow_subset=True,\n    attempt_supercell=True,\n    lattice_params: bool = False,\n):\n    \"\"\"\n    To check if pymatgen object from the original cif file match with the generated...\n    pymatgen structure from wyckoff_decoder method out of wyckoff representation...\n    using fit() method of StructureMatcher module in pymatgen package.\n\n    Params:\n        StructureMatcher module can be access in below link with its parameters:\n            https://pymatgen.org/pymatgen.analysis.html#pymatgen.analysis.structure_matcher.StructureMatcher.get_mapping\n        lattice_params: bool\n            To specify using lattice parameters in the wyckoff_decoder method.\n\n    Returns:\n        StructureMatcher().fit_anonymous(): bool\n    \"\"\"\n\n    original_struct = self.structure\n\n    # output_struct = self.wyckoff_decoder(input, lattice_params)\n    output_struct = DecodeTextRep(self.text).wyckoff_decoder(self.text, lattice_params=True)\n\n    return StructureMatcher(\n        ltol,\n        stol,\n        angle_tol,\n        primitive_cell,\n        scale,\n        allow_subset,\n        attempt_supercell,\n    ).fit_anonymous(output_struct, original_struct)\n</code></pre>"},{"location":"api/#transformations","title":"Transformations","text":""},{"location":"api/#xtal2txt.transforms.TransformationCallback","title":"<code>TransformationCallback</code>","text":"Source code in <code>src/xtal2txt/transforms.py</code> <pre><code>class TransformationCallback:\n    @staticmethod\n    def permute_structure(structure: Structure, seed: int = 42) -&gt; Structure:\n        \"\"\"\n        Randomly permute the order of atoms in a structure.\n        \"\"\"\n        set_seed(seed)\n        shuffled_structure = structure.copy()\n        sites = shuffled_structure.sites\n        random.shuffle(sites)\n        shuffled_structure.sites = sites\n        return shuffled_structure\n\n    @staticmethod\n    def translate_structure(\n        structure: Structure,\n        vector: Union[List[float], None] = None,\n        seed: int = 42,\n        **kwargs,\n    ) -&gt; Structure:\n        \"\"\"\n        Randomly translate the atoms in a structure.\n        \"\"\"\n        set_seed(seed)\n\n        if vector is None:\n            vector = np.random.uniform(size=(3,))\n\n        structure.translate_sites(\n            indices=range(len(structure.sites)),\n            vector=vector,\n            # frac_coords=True,\n            **kwargs,\n        )\n        return structure\n\n    @staticmethod\n    def translate_single_atom(\n        structure: Structure,\n        max_indices: int = 1,\n        vector: List[float] = [0.25, 0.25, 0.25],\n        seed: int = 42,\n        **kwargs,\n    ) -&gt; Structure:\n        \"\"\"\n        Randomly translate one or more atoms in a structure.\n\n        Args:\n            structure (Structure): The input structure.\n            max_indices (int): The maximum number of atoms to translate. Defaults to 1.\n            vector (List[float]): The translation vector. Defaults to [0.25, 0.25, 0.25].\n            seed (int): The seed for random number generation. Defaults to 42.\n\n        Returns:\n            Structure: The transformed structure.\n        \"\"\"\n        set_seed(seed)\n        indices = random.sample(\n            range(len(structure.sites)), min(max_indices, len(structure.sites))\n        )  # ensures that we select at most max_indices from the available sites\n        structure.translate_sites(indices=indices, vector=vector, frac_coords=True, **kwargs)\n        return structure\n\n    @staticmethod\n    def perturb_structure(\n        structure: Structure, max_distance: float, seed: int = 42, **kwargs\n    ) -&gt; Structure:\n        \"\"\"\n        Randomly perturb atoms in a structure.\n        \"\"\"\n        set_seed(seed)\n        distance = random.uniform(0, max_distance)\n        structure.perturb(distance=distance, **kwargs)\n        return structure\n</code></pre>"},{"location":"api/#xtal2txt.transforms.TransformationCallback.permute_structure","title":"<code>permute_structure(structure, seed=42)</code>  <code>staticmethod</code>","text":"<p>Randomly permute the order of atoms in a structure.</p> Source code in <code>src/xtal2txt/transforms.py</code> <pre><code>@staticmethod\ndef permute_structure(structure: Structure, seed: int = 42) -&gt; Structure:\n    \"\"\"\n    Randomly permute the order of atoms in a structure.\n    \"\"\"\n    set_seed(seed)\n    shuffled_structure = structure.copy()\n    sites = shuffled_structure.sites\n    random.shuffle(sites)\n    shuffled_structure.sites = sites\n    return shuffled_structure\n</code></pre>"},{"location":"api/#xtal2txt.transforms.TransformationCallback.perturb_structure","title":"<code>perturb_structure(structure, max_distance, seed=42, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Randomly perturb atoms in a structure.</p> Source code in <code>src/xtal2txt/transforms.py</code> <pre><code>@staticmethod\ndef perturb_structure(\n    structure: Structure, max_distance: float, seed: int = 42, **kwargs\n) -&gt; Structure:\n    \"\"\"\n    Randomly perturb atoms in a structure.\n    \"\"\"\n    set_seed(seed)\n    distance = random.uniform(0, max_distance)\n    structure.perturb(distance=distance, **kwargs)\n    return structure\n</code></pre>"},{"location":"api/#xtal2txt.transforms.TransformationCallback.translate_single_atom","title":"<code>translate_single_atom(structure, max_indices=1, vector=[0.25, 0.25, 0.25], seed=42, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Randomly translate one or more atoms in a structure.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Structure</code> <p>The input structure.</p> required <code>max_indices</code> <code>int</code> <p>The maximum number of atoms to translate. Defaults to 1.</p> <code>1</code> <code>vector</code> <code>List[float]</code> <p>The translation vector. Defaults to [0.25, 0.25, 0.25].</p> <code>[0.25, 0.25, 0.25]</code> <code>seed</code> <code>int</code> <p>The seed for random number generation. Defaults to 42.</p> <code>42</code> <p>Returns:</p> Name Type Description <code>Structure</code> <code>Structure</code> <p>The transformed structure.</p> Source code in <code>src/xtal2txt/transforms.py</code> <pre><code>@staticmethod\ndef translate_single_atom(\n    structure: Structure,\n    max_indices: int = 1,\n    vector: List[float] = [0.25, 0.25, 0.25],\n    seed: int = 42,\n    **kwargs,\n) -&gt; Structure:\n    \"\"\"\n    Randomly translate one or more atoms in a structure.\n\n    Args:\n        structure (Structure): The input structure.\n        max_indices (int): The maximum number of atoms to translate. Defaults to 1.\n        vector (List[float]): The translation vector. Defaults to [0.25, 0.25, 0.25].\n        seed (int): The seed for random number generation. Defaults to 42.\n\n    Returns:\n        Structure: The transformed structure.\n    \"\"\"\n    set_seed(seed)\n    indices = random.sample(\n        range(len(structure.sites)), min(max_indices, len(structure.sites))\n    )  # ensures that we select at most max_indices from the available sites\n    structure.translate_sites(indices=indices, vector=vector, frac_coords=True, **kwargs)\n    return structure\n</code></pre>"},{"location":"api/#xtal2txt.transforms.TransformationCallback.translate_structure","title":"<code>translate_structure(structure, vector=None, seed=42, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Randomly translate the atoms in a structure.</p> Source code in <code>src/xtal2txt/transforms.py</code> <pre><code>@staticmethod\ndef translate_structure(\n    structure: Structure,\n    vector: Union[List[float], None] = None,\n    seed: int = 42,\n    **kwargs,\n) -&gt; Structure:\n    \"\"\"\n    Randomly translate the atoms in a structure.\n    \"\"\"\n    set_seed(seed)\n\n    if vector is None:\n        vector = np.random.uniform(size=(3,))\n\n    structure.translate_sites(\n        indices=range(len(structure.sites)),\n        vector=vector,\n        # frac_coords=True,\n        **kwargs,\n    )\n    return structure\n</code></pre>"},{"location":"api/#xtal2txt.transforms.set_seed","title":"<code>set_seed(seed)</code>","text":"<p>Set the random seed for both random and numpy.random.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>The seed value.</p> required Source code in <code>src/xtal2txt/transforms.py</code> <pre><code>def set_seed(seed: int):\n    \"\"\"\n    Set the random seed for both random and numpy.random.\n\n    Parameters:\n        seed (int): The seed value.\n    \"\"\"\n    random.seed(seed)\n    np.random.seed(seed)\n</code></pre>"},{"location":"api/#tokenizer","title":"Tokenizer","text":""},{"location":"api/#xtal2txt.tokenizer.CifTokenizer","title":"<code>CifTokenizer</code>","text":"<p>               Bases: <code>Xtal2txtTokenizer</code></p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>class CifTokenizer(Xtal2txtTokenizer):\n    def __init__(\n        self,\n        special_num_token: bool = False,\n        vocab_file=None,\n        model_max_length=None,\n        padding_length=None,\n        **kwargs,\n    ):\n        if special_num_token:\n            vocab_file = CIF_RT_VOCAB\n        else:\n            vocab_file = CIF_VOCAB\n        super(CifTokenizer, self).__init__(\n            special_num_token=special_num_token,\n            vocab_file=vocab_file,\n            model_max_length=model_max_length,\n            padding_length=padding_length,\n            **kwargs,\n        )\n\n    def token_analysis(self, list_of_tokens):\n        \"\"\"Takes tokens after tokenize and returns a list with replacing the tokens with their MASK token. The\n        token type is determined from the dict declared globally, and the token is replaced with the corresponding MASK token.\n        \"\"\"\n        analysis_masks = ANALYSIS_MASK_TOKENS\n        token_type = CIF_ANALYSIS_DICT\n        return [\n            analysis_masks[next((k for k, v in token_type.items() if token in v), None)]\n            for token in list_of_tokens\n        ]\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.CifTokenizer.token_analysis","title":"<code>token_analysis(list_of_tokens)</code>","text":"<p>Takes tokens after tokenize and returns a list with replacing the tokens with their MASK token. The token type is determined from the dict declared globally, and the token is replaced with the corresponding MASK token.</p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>def token_analysis(self, list_of_tokens):\n    \"\"\"Takes tokens after tokenize and returns a list with replacing the tokens with their MASK token. The\n    token type is determined from the dict declared globally, and the token is replaced with the corresponding MASK token.\n    \"\"\"\n    analysis_masks = ANALYSIS_MASK_TOKENS\n    token_type = CIF_ANALYSIS_DICT\n    return [\n        analysis_masks[next((k for k, v in token_type.items() if token in v), None)]\n        for token in list_of_tokens\n    ]\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.CompositionTokenizer","title":"<code>CompositionTokenizer</code>","text":"<p>               Bases: <code>Xtal2txtTokenizer</code></p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>class CompositionTokenizer(Xtal2txtTokenizer):\n    def __init__(\n        self,\n        special_num_token: bool = False,\n        vocab_file=None,\n        model_max_length=None,\n        padding_length=None,\n        **kwargs,\n    ):\n        if special_num_token:\n            vocab_file = COMPOSITION_RT_VOCAB if vocab_file is None else vocab_file\n        else:\n            vocab_file = COMPOSITION_VOCAB if vocab_file is None else vocab_file\n        super(CompositionTokenizer, self).__init__(\n            special_num_token=special_num_token,\n            vocab_file=vocab_file,\n            model_max_length=model_max_length,\n            padding_length=padding_length,\n            **kwargs,\n        )\n\n    def token_analysis(self, list_of_tokens):\n        \"\"\"Takes tokens after tokenize and returns a list with replacing the tokens with their MASK token. The\n        token type is determined from the dict declared globally, and the token is replaced with the corresponding MASK token.\n        \"\"\"\n        analysis_masks = ANALYSIS_MASK_TOKENS\n        token_type = COMPOSITION_ANALYSIS_DICT\n        return [\n            analysis_masks[next((k for k, v in token_type.items() if token in v), None)]\n            for token in list_of_tokens\n        ]\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.CompositionTokenizer.token_analysis","title":"<code>token_analysis(list_of_tokens)</code>","text":"<p>Takes tokens after tokenize and returns a list with replacing the tokens with their MASK token. The token type is determined from the dict declared globally, and the token is replaced with the corresponding MASK token.</p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>def token_analysis(self, list_of_tokens):\n    \"\"\"Takes tokens after tokenize and returns a list with replacing the tokens with their MASK token. The\n    token type is determined from the dict declared globally, and the token is replaced with the corresponding MASK token.\n    \"\"\"\n    analysis_masks = ANALYSIS_MASK_TOKENS\n    token_type = COMPOSITION_ANALYSIS_DICT\n    return [\n        analysis_masks[next((k for k, v in token_type.items() if token in v), None)]\n        for token in list_of_tokens\n    ]\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.CrysllmTokenizer","title":"<code>CrysllmTokenizer</code>","text":"<p>               Bases: <code>Xtal2txtTokenizer</code></p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>class CrysllmTokenizer(Xtal2txtTokenizer):\n    def __init__(\n        self,\n        special_num_token: bool = False,\n        vocab_file=CRYSTAL_LLM_VOCAB,\n        model_max_length=None,\n        padding_length=None,\n        **kwargs,\n    ):\n        if special_num_token:\n            vocab_file = CRYSTAL_LLM_RT_VOCAB\n        else:\n            vocab_file = CRYSTAL_LLM_VOCAB\n        super(CrysllmTokenizer, self).__init__(\n            special_num_token=special_num_token,\n            vocab_file=vocab_file,\n            model_max_length=model_max_length,\n            padding_length=padding_length,\n            **kwargs,\n        )\n\n    def token_analysis(self, list_of_tokens):\n        \"\"\"Takes tokens after tokenize and returns a list with replacing the tokens with their MASK token. The\n        token type is determined from the dict declared globally, and the token is replaced with the corresponding MASK token.\n        \"\"\"\n        analysis_masks = ANALYSIS_MASK_TOKENS\n        token_type = CRYSTAL_LLM_ANALYSIS_DICT\n        return [\n            analysis_masks[next((k for k, v in token_type.items() if token in v), None)]\n            for token in list_of_tokens\n        ]\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.CrysllmTokenizer.token_analysis","title":"<code>token_analysis(list_of_tokens)</code>","text":"<p>Takes tokens after tokenize and returns a list with replacing the tokens with their MASK token. The token type is determined from the dict declared globally, and the token is replaced with the corresponding MASK token.</p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>def token_analysis(self, list_of_tokens):\n    \"\"\"Takes tokens after tokenize and returns a list with replacing the tokens with their MASK token. The\n    token type is determined from the dict declared globally, and the token is replaced with the corresponding MASK token.\n    \"\"\"\n    analysis_masks = ANALYSIS_MASK_TOKENS\n    token_type = CRYSTAL_LLM_ANALYSIS_DICT\n    return [\n        analysis_masks[next((k for k, v in token_type.items() if token in v), None)]\n        for token in list_of_tokens\n    ]\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.NumTokenizer","title":"<code>NumTokenizer</code>","text":"<p>Tokenize numbers as implemented in Regression Transformer. https://www.nature.com/articles/s42256-023-00639-z https://github.com/IBM/regression-transformer/tree/main</p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>class NumTokenizer:\n    \"\"\"Tokenize numbers as implemented in Regression Transformer.\n    https://www.nature.com/articles/s42256-023-00639-z\n    https://github.com/IBM/regression-transformer/tree/main\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Tokenizer for numbers.\"\"\"\n        self.regex = re.compile(r\"(\\+|-)?(\\d+)(\\.)?(\\d+)?\\s*\")\n\n    def num_matcher(self, text: str) -&gt; str:\n        \"\"\"Extract numbers from a sentence and replace them with tokens.\"\"\"\n        # pattern = re.findall(r'(\\d+\\.\\d+|\\d+)', text)  # This regex captures both whole numbers and decimal numbers\n\n        pattern = (\n            r\"\\d+(?:\\.\\d+)?\"  # Match any number, whether it is part of a string or not\n        )\n        matches = list(re.finditer(pattern, text))\n        for match in reversed(\n            matches\n        ):  # since we are replacing substring with a bigger subtring the string we are working on\n            start, end = match.start(), match.end()\n            tokens = self.tokenize(match.group())\n            replacement = \"\".join(tokens)\n            text = text[:start] + replacement + text[end:]\n        return text\n\n    def tokenize(self, text: str) -&gt; List[str]:\n        \"\"\"Tokenization of numbers as in RT.\n         '0.9' -&gt; '_0_0_', '_._', '_9_-1_'\n\n        Args:\n            text: number as string to be tokenized.\n\n        Returns:\n            extracted tokens.\n        \"\"\"\n        tokens = []\n        matched = self.regex.match(text)\n        if matched:\n            sign, units, dot, decimals = matched.groups()\n            tokens = []\n            if sign:\n                tokens += [f\"_{sign}_\"]\n            tokens += [\n                f\"_{number}_{position}_\" for position, number in enumerate(units[::-1])\n            ][::-1]\n            if dot:\n                tokens += [f\"_{dot}_\"]\n            if decimals:\n                tokens += [\n                    f\"_{number}_-{position}_\"\n                    for position, number in enumerate(decimals, 1)\n                ]\n        return tokens\n\n    @staticmethod\n    def convert_tokens_to_float(tokens: List[str]) -&gt; float:\n        \"\"\"Converts tokens representing a float value into a float.\n        NOTE: Expects that non-floating tokens are strippped off\n\n        Args:\n            tokens: List of tokens, each representing a float.\n                E.g.: ['_0_0_', '_._', '_9_-1_', '_3_-2_', '_1_-3_']\n\n        Returns:\n            float: Float representation for the list of tokens.\n        \"\"\"\n        try:\n            float_string = \"\".join([token.split(\"_\")[1] for token in tokens])\n            float_value = float(float_string)\n        except ValueError:\n            float_value = -1\n        return float_value\n\n    def convert_tokens_to_string(self, tokens: List[str]) -&gt; str:\n        \"\"\"Converts tokens to string.\n\n        Args:\n            tokens: List of tokens.\n\n        Returns:\n            str: String representation of the tokens.\n        \"\"\"\n        return \"\".join([token.split(\"_\")[1] for token in tokens])\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.NumTokenizer.__init__","title":"<code>__init__()</code>","text":"<p>Tokenizer for numbers.</p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Tokenizer for numbers.\"\"\"\n    self.regex = re.compile(r\"(\\+|-)?(\\d+)(\\.)?(\\d+)?\\s*\")\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.NumTokenizer.convert_tokens_to_float","title":"<code>convert_tokens_to_float(tokens)</code>  <code>staticmethod</code>","text":"<p>Converts tokens representing a float value into a float. NOTE: Expects that non-floating tokens are strippped off</p> <p>Parameters:</p> Name Type Description Default <code>tokens</code> <code>List[str]</code> <p>List of tokens, each representing a float. E.g.: ['0_0', '.', '9-1_', '3-2_', '1-3_']</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Float representation for the list of tokens.</p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>@staticmethod\ndef convert_tokens_to_float(tokens: List[str]) -&gt; float:\n    \"\"\"Converts tokens representing a float value into a float.\n    NOTE: Expects that non-floating tokens are strippped off\n\n    Args:\n        tokens: List of tokens, each representing a float.\n            E.g.: ['_0_0_', '_._', '_9_-1_', '_3_-2_', '_1_-3_']\n\n    Returns:\n        float: Float representation for the list of tokens.\n    \"\"\"\n    try:\n        float_string = \"\".join([token.split(\"_\")[1] for token in tokens])\n        float_value = float(float_string)\n    except ValueError:\n        float_value = -1\n    return float_value\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.NumTokenizer.convert_tokens_to_string","title":"<code>convert_tokens_to_string(tokens)</code>","text":"<p>Converts tokens to string.</p> <p>Parameters:</p> Name Type Description Default <code>tokens</code> <code>List[str]</code> <p>List of tokens.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the tokens.</p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>def convert_tokens_to_string(self, tokens: List[str]) -&gt; str:\n    \"\"\"Converts tokens to string.\n\n    Args:\n        tokens: List of tokens.\n\n    Returns:\n        str: String representation of the tokens.\n    \"\"\"\n    return \"\".join([token.split(\"_\")[1] for token in tokens])\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.NumTokenizer.num_matcher","title":"<code>num_matcher(text)</code>","text":"<p>Extract numbers from a sentence and replace them with tokens.</p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>def num_matcher(self, text: str) -&gt; str:\n    \"\"\"Extract numbers from a sentence and replace them with tokens.\"\"\"\n    # pattern = re.findall(r'(\\d+\\.\\d+|\\d+)', text)  # This regex captures both whole numbers and decimal numbers\n\n    pattern = (\n        r\"\\d+(?:\\.\\d+)?\"  # Match any number, whether it is part of a string or not\n    )\n    matches = list(re.finditer(pattern, text))\n    for match in reversed(\n        matches\n    ):  # since we are replacing substring with a bigger subtring the string we are working on\n        start, end = match.start(), match.end()\n        tokens = self.tokenize(match.group())\n        replacement = \"\".join(tokens)\n        text = text[:start] + replacement + text[end:]\n    return text\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.NumTokenizer.tokenize","title":"<code>tokenize(text)</code>","text":"<p>Tokenization of numbers as in RT.  '0.9' -&gt; '0_0', '.', '9-1_'</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>number as string to be tokenized.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>extracted tokens.</p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>def tokenize(self, text: str) -&gt; List[str]:\n    \"\"\"Tokenization of numbers as in RT.\n     '0.9' -&gt; '_0_0_', '_._', '_9_-1_'\n\n    Args:\n        text: number as string to be tokenized.\n\n    Returns:\n        extracted tokens.\n    \"\"\"\n    tokens = []\n    matched = self.regex.match(text)\n    if matched:\n        sign, units, dot, decimals = matched.groups()\n        tokens = []\n        if sign:\n            tokens += [f\"_{sign}_\"]\n        tokens += [\n            f\"_{number}_{position}_\" for position, number in enumerate(units[::-1])\n        ][::-1]\n        if dot:\n            tokens += [f\"_{dot}_\"]\n        if decimals:\n            tokens += [\n                f\"_{number}_-{position}_\"\n                for position, number in enumerate(decimals, 1)\n            ]\n    return tokens\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.RobocrysTokenizer","title":"<code>RobocrysTokenizer</code>","text":"<p>Tokenizer for Robocrystallographer. Would be BPE tokenizer. trained on the Robocrystallographer dataset. TODO: Implement this tokenizer.</p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>class RobocrysTokenizer:\n    \"\"\"Tokenizer for Robocrystallographer. Would be BPE tokenizer.\n    trained on the Robocrystallographer dataset.\n    TODO: Implement this tokenizer.\n    \"\"\"\n\n    def __init__(self, vocab_file=ROBOCRYS_VOCAB, **kwargs):\n        tokenizer = Tokenizer.from_file(vocab_file)\n        wrapped_tokenizer = PreTrainedTokenizerFast(tokenizer_object=tokenizer)\n        self._tokenizer = wrapped_tokenizer\n\n    def tokenize(self, text):\n        return self._tokenizer.tokenize(text)\n\n    def encode(self, text):\n        return self._tokenizer.encode(text)\n\n    def decode(self, token_ids, skip_special_tokens=True):\n        # Check if token_ids is a string and convert it to a list of integers\n        if isinstance(token_ids, str):\n            token_ids = [int(token_ids)]\n        return self._tokenizer.decode(\n            token_ids, skip_special_tokens=skip_special_tokens\n        )\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.SliceTokenizer","title":"<code>SliceTokenizer</code>","text":"<p>               Bases: <code>Xtal2txtTokenizer</code></p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>class SliceTokenizer(Xtal2txtTokenizer):\n    def __init__(\n        self,\n        special_num_token: bool = False,\n        vocab_file=None,\n        model_max_length=None,\n        padding_length=None,\n        **kwargs,\n    ):\n        if special_num_token:\n            vocab_file = SLICE_RT_VOCAB if vocab_file is None else vocab_file\n        else:\n            vocab_file = SLICE_VOCAB if vocab_file is None else vocab_file\n        super(SliceTokenizer, self).__init__(\n            special_num_token=special_num_token,\n            vocab_file=vocab_file,\n            model_max_length=model_max_length,\n            padding_length=padding_length,\n            **kwargs,\n        )\n\n    def convert_tokens_to_string(self, tokens):\n        \"\"\"Converts tokens to string.\"\"\"\n        if self.special_num_tokens:\n            return \" \".join(\n                [\n                    (\n                        token\n                        if not (token.startswith(\"_\") and token.endswith(\"_\"))\n                        else token.split(\"_\")[1]\n                    )\n                    for token in tokens\n                ]\n            )\n        return \" \".join(tokens).rstrip()\n\n    def token_analysis(self, list_of_tokens):\n        \"\"\"Takes tokens after tokenize and returns a list with replacing the tokens with their MASK token. The\n        token type is determined from the dict declared globally, and the token is replaced with the corresponding MASK token.\n        \"\"\"\n        analysis_masks = ANALYSIS_MASK_TOKENS\n        token_type = SLICE_ANALYSIS_DICT\n        return [\n            analysis_masks[next((k for k, v in token_type.items() if token in v), None)]\n            for token in list_of_tokens\n        ]\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.SliceTokenizer.convert_tokens_to_string","title":"<code>convert_tokens_to_string(tokens)</code>","text":"<p>Converts tokens to string.</p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>def convert_tokens_to_string(self, tokens):\n    \"\"\"Converts tokens to string.\"\"\"\n    if self.special_num_tokens:\n        return \" \".join(\n            [\n                (\n                    token\n                    if not (token.startswith(\"_\") and token.endswith(\"_\"))\n                    else token.split(\"_\")[1]\n                )\n                for token in tokens\n            ]\n        )\n    return \" \".join(tokens).rstrip()\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.SliceTokenizer.token_analysis","title":"<code>token_analysis(list_of_tokens)</code>","text":"<p>Takes tokens after tokenize and returns a list with replacing the tokens with their MASK token. The token type is determined from the dict declared globally, and the token is replaced with the corresponding MASK token.</p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>def token_analysis(self, list_of_tokens):\n    \"\"\"Takes tokens after tokenize and returns a list with replacing the tokens with their MASK token. The\n    token type is determined from the dict declared globally, and the token is replaced with the corresponding MASK token.\n    \"\"\"\n    analysis_masks = ANALYSIS_MASK_TOKENS\n    token_type = SLICE_ANALYSIS_DICT\n    return [\n        analysis_masks[next((k for k, v in token_type.items() if token in v), None)]\n        for token in list_of_tokens\n    ]\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.Xtal2txtTokenizer","title":"<code>Xtal2txtTokenizer</code>","text":"<p>               Bases: <code>PreTrainedTokenizer</code></p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>class Xtal2txtTokenizer(PreTrainedTokenizer):\n    def __init__(\n        self,\n        special_num_token: bool = False,\n        vocab_file=None,\n        special_tokens={\n            \"cls_token\": \"[CLS]\",\n            \"sep_token\": \"[SEP]\",\n        },\n        model_max_length=None,\n        padding_length=None,\n        **kwargs,\n    ):\n        super(Xtal2txtTokenizer, self).__init__(\n            model_max_length=model_max_length, **kwargs\n        )\n        self.truncation = False\n        self.padding = False\n        self.padding_length = padding_length\n\n        self.special_num_tokens = special_num_token\n        self.vocab = self.load_vocab(vocab_file)\n        self.vocab_file = vocab_file\n\n        # Initialize special tokens\n        self.special_tokens = special_tokens if special_tokens is not None else {}\n        self.add_special_tokens(self.special_tokens)\n\n    def load_vocab(self, vocab_file):\n        _, file_extension = os.path.splitext(vocab_file)\n        if file_extension == \".txt\":\n            with open(vocab_file, \"r\", encoding=\"utf-8\") as file:\n                vocab = file.read().splitlines()\n            return {token: idx for idx, token in enumerate(vocab)}\n        elif file_extension == \".json\":\n            with open(vocab_file, \"r\", encoding=\"utf-8\") as file:\n                return json.load(file)\n        else:\n            raise ValueError(f\"Unsupported file type: {file_extension}\")\n\n    def get_vocab(self):\n        return self.vocab\n\n    def get_special_num_tokens(self, text):\n        num_tokenizer = NumTokenizer()\n        return num_tokenizer.num_matcher(text)\n\n    def tokenize(self, text):\n        if self.special_num_tokens:\n            text = self.get_special_num_tokens(text)\n\n        tokens = list(self.vocab.keys())\n        string_tokens = [token for token in tokens if isinstance(token, str)]\n        string_tokens.sort(key=len, reverse=True)\n        escaped_tokens = [re.escape(token) for token in string_tokens]\n        pattern_str = \"|\".join(escaped_tokens)\n        pattern = re.compile(pattern_str)\n        matches = pattern.findall(text)\n\n        # Add [CLS] and [SEP] tokens if present in the vocabulary\n        if self.cls_token is not None:\n            matches = [self.cls_token] + matches\n\n        if self.truncation and len(matches) &gt; self.model_max_length:\n            matches = matches[\n                : self.model_max_length - 1\n            ]  # -1 since we add sep token later\n\n        if self.sep_token is not None:\n            matches += [self.sep_token]\n\n        if self.padding and len(matches) &lt; self.padding_length:\n            matches += [self.pad_token] * (self.padding_length - len(matches))\n\n        return matches\n\n    def convert_tokens_to_string(self, tokens):\n        \"\"\"Converts tokens to string.\"\"\"\n        if self.special_num_tokens:\n            return \"\".join(\n                [\n                    (\n                        token\n                        if not (token.startswith(\"_\") and token.endswith(\"_\"))\n                        else token.split(\"_\")[1]\n                    )\n                    for token in tokens\n                ]\n            )\n        return \"\".join(tokens)\n\n    def _add_tokens(self, new_tokens, **kwargs):\n        for token in new_tokens:\n            if token not in self.added_tokens_encoder:\n                self.vocab[token] = len(self.vocab)\n\n    def _convert_token_to_id(self, token):\n        return self.vocab.get(token, self.vocab.get(self.unk_token))\n\n    def _convert_id_to_token(self, index):\n        return list(self.vocab.keys())[index]\n\n    def enable_truncation(self, max_length):\n        self.model_max_length = max_length\n        self.truncation = True\n\n    def disable_truncation(self):\n        self.truncation = False\n\n    def enable_padding(self, length=None):\n        self.padding = True\n        self.padding_length = length\n\n    def disable_padding(self):\n        self.padding = False\n\n    def add_special_tokens(self, special_tokens):\n        for token, value in special_tokens.items():\n            if value not in self.vocab:\n                setattr(self, token, value)\n                self.vocab[value] = len(self.vocab)\n\n        # Ensure [CLS] and [SEP] tokens are added\n        cls_token = special_tokens.get(\"cls_token\", None)\n        sep_token = special_tokens.get(\"sep_token\", None)\n        if cls_token is not None and cls_token not in self.vocab:\n            setattr(self, \"cls_token\", cls_token)\n            self.vocab[cls_token] = len(self.vocab)\n        if sep_token is not None and sep_token not in self.vocab:\n            setattr(self, \"sep_token\", sep_token)\n            self.vocab[sep_token] = len(self.vocab)\n        self.save_vocabulary(os.path.dirname(self.vocab_file))\n\n    def token_analysis(self, tokens):\n        \"\"\"This method should be implemented by the Downstream tokenizers.\"\"\"\n        raise NotImplementedError\n\n    def save_vocabulary(self, save_directory, filename_prefix=None):\n        \"\"\"Save the vocabulary, ensures vocabularies are not overwritten. Filename follow the convention {index}-{filename_prefix}.json. Index keeps track of the latest vocabulary saved.\"\"\"\n        index = 0\n        if os.path.isdir(save_directory):\n            vocab_files = list(\n                filter(lambda x: x.endswith(\".json\"), os.listdir(save_directory))\n            )\n            for vocab_file in vocab_files:\n                try:\n                    index = max(index, int(vocab_file.split(\"-\")[0]))\n                except ValueError:\n                    pass  # Ignore files that do not start with an integer\n\n        vocab_file = os.path.join(\n            save_directory,\n            (\n                f\"{index + 1}-{filename_prefix}.json\"\n                if filename_prefix\n                else f\"{index + 1}.json\"\n            ),\n        )\n\n        with open(vocab_file, \"w\", encoding=\"utf-8\") as f:\n            json.dump(self.vocab, f, ensure_ascii=False)\n\n        return (vocab_file,)\n\n    @classmethod\n    def from_pretrained(cls, pretrained_model_name_or_path, *inputs, **kwargs):\n        if pretrained_model_name_or_path is not None:\n            if os.path.isdir(pretrained_model_name_or_path):\n                vocab_files = list(\n                    filter(\n                        lambda x: x.endswith(\".json\"),\n                        os.listdir(pretrained_model_name_or_path),\n                    )\n                )\n                vocab_files.sort(key=lambda x: int(x.split(\"-\")[0]))\n                vocab_file = os.path.join(\n                    pretrained_model_name_or_path, vocab_files[-1]\n                )\n\n        if vocab_file is None:\n            raise ValueError(\"You should specify a path to a vocab file\")\n\n        with open(vocab_file, \"r\", encoding=\"utf-8\") as f:\n            vocab = json.load(f)\n\n        tokenizer = cls(vocab_file, *inputs, **kwargs)\n        tokenizer.vocab = vocab\n\n        return tokenizer\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.Xtal2txtTokenizer.convert_tokens_to_string","title":"<code>convert_tokens_to_string(tokens)</code>","text":"<p>Converts tokens to string.</p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>def convert_tokens_to_string(self, tokens):\n    \"\"\"Converts tokens to string.\"\"\"\n    if self.special_num_tokens:\n        return \"\".join(\n            [\n                (\n                    token\n                    if not (token.startswith(\"_\") and token.endswith(\"_\"))\n                    else token.split(\"_\")[1]\n                )\n                for token in tokens\n            ]\n        )\n    return \"\".join(tokens)\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.Xtal2txtTokenizer.save_vocabulary","title":"<code>save_vocabulary(save_directory, filename_prefix=None)</code>","text":"<p>Save the vocabulary, ensures vocabularies are not overwritten. Filename follow the convention {index}-{filename_prefix}.json. Index keeps track of the latest vocabulary saved.</p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>def save_vocabulary(self, save_directory, filename_prefix=None):\n    \"\"\"Save the vocabulary, ensures vocabularies are not overwritten. Filename follow the convention {index}-{filename_prefix}.json. Index keeps track of the latest vocabulary saved.\"\"\"\n    index = 0\n    if os.path.isdir(save_directory):\n        vocab_files = list(\n            filter(lambda x: x.endswith(\".json\"), os.listdir(save_directory))\n        )\n        for vocab_file in vocab_files:\n            try:\n                index = max(index, int(vocab_file.split(\"-\")[0]))\n            except ValueError:\n                pass  # Ignore files that do not start with an integer\n\n    vocab_file = os.path.join(\n        save_directory,\n        (\n            f\"{index + 1}-{filename_prefix}.json\"\n            if filename_prefix\n            else f\"{index + 1}.json\"\n        ),\n    )\n\n    with open(vocab_file, \"w\", encoding=\"utf-8\") as f:\n        json.dump(self.vocab, f, ensure_ascii=False)\n\n    return (vocab_file,)\n</code></pre>"},{"location":"api/#xtal2txt.tokenizer.Xtal2txtTokenizer.token_analysis","title":"<code>token_analysis(tokens)</code>","text":"<p>This method should be implemented by the Downstream tokenizers.</p> Source code in <code>src/xtal2txt/tokenizer.py</code> <pre><code>def token_analysis(self, tokens):\n    \"\"\"This method should be implemented by the Downstream tokenizers.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"getting_started/","title":"Installation","text":"<p>The most recent release can be installed from PyPI with:</p> <pre><code>$ pip install xtal2txt\n</code></pre> <p>The most recent code and data can be installed directly from GitHub with:</p> <pre><code>$ pip install git+https://github.com/lamalab-org/xtal2txt.git\n</code></pre> <p>To install in development mode, use the following:</p> <pre><code>$ git clone git+https://github.com/lamalab-org/xtal2txt.git\n$ cd xtal2txt\n$ pip install -e .\n</code></pre>"},{"location":"usage/","title":"Text representation with xtal2txt","text":"<p>The <code>TextRep</code> class in <code>xtal2txt.core</code> facilitates the transformation of crystal structures into different text representations. Below is an example of its usage:</p> <pre><code>from xtal2txt.core import TextRep\nfrom pymatgen.core import Structure\n\n\n# Load structure from a CIF file\nfrom_file = \"InCuS2_p1.cif\"\nstructure = Structure.from_file(from_file, \"cif\")\n\nInitialize TextRep Class\ntext_rep = TextRep.from_input(structure)\n</code></pre>"},{"location":"usage/#get_requested_text_reps-method","title":"<code>get_requested_text_reps</code> method","text":"<p>The <code>get_requested_text_reps</code> method retrieves the requested text representations of the crystal structure and returns them in a dictionary.</p> <p>For example, to obtain the <code>cif_p1</code>, <code>slice</code>, <code>atoms_params</code>, <code>crystal_llm_rep</code>, and <code>zmatrix</code> representations, use the following code:</p> <pre><code>text_rep = TextRep(structure)\n\n# Define a list of requested representations\nrequested_reps = [\n    \"cif_p1\",\n    \"slices\",\n    \"atom_sequences_plusplus\",\n    \"crystal_text_llm\",\n    \"zmatrix\"\n]\n\n# Get the requested text representations\nrequested_text_reps = text_rep.get_requested_text_reps(requested_reps)\n</code></pre>"},{"location":"usage/#supported-text-representations","title":"Supported text representations","text":"<p>The <code>TextRep</code> class currently supports the following text representations:</p> <ul> <li>SlICES (<code>slices</code>): SLICE representation of the crystal structure.</li> <li>Composition (<code>composition</code>): Chemical composition in hill format.</li> <li>CIF Symmetrized (<code>cif_symmetrized</code>): Multi-line CIF representation with symmetrized structure and rounded float numbers.</li> <li>CIF \\(P_1\\) (<code>cif_p1</code>): Multi-line CIF representation with the conventional unit cell and rounded float numbers.</li> <li>Crystal-text-LLM Representation (<code>crystal_text_llm</code>): Representation following the format specified in the cited work.</li> <li>Robocrystallographer Representation (<code>robocrys_rep</code>): Representation generated by Robocrystallographer.</li> <li>Atom Sequences (<code>atom_sequences</code>): List of atoms inside the unit cell.</li> <li>Atoms Sequences++ (<code>atom_sequences_plusplus</code>): List of atoms with lattice parameters.</li> <li>Z-Matrix (<code>zmatrix</code>): Z-Matrix representation of the crystal structure.</li> <li>Local Env (<code>local_env</code>):  List of Wyckoff label and SMILES separated by line breaks for each local environment.</li> </ul> <p>For more details on each representation and how to obtain them, refer to the respective method documentation in the <code>TextRep</code> class.</p>"},{"location":"usage/#transformations","title":"Transformations","text":"<p>The <code>TextRep</code> class supports various transformations that can be applied to the input structure.</p>"},{"location":"usage/#permute-structure","title":"Permute Structure","text":"<p>The <code>permute_structure</code> transformation randomly permutes the order of atoms in a structure. </p>"},{"location":"usage/#example","title":"Example:","text":"<pre><code>from xtal2txt.core import TextRep\nfrom pymatgen.core.structure import Structure\n\nstructure_1 = Structure.from_file(\"N2_p1.cif\", \"cif\")\n\ntransformations = [(\"permute_structure\", {\"seed\": 42})]\n\ntext_rep = TextRep.from_input(structure_1, transformations)\ntext_representations_requested = [\"atoms\", \"crystal_llm_rep\"]\nprint(\"Permuted Pymatgen Structure:\")\nprint(text_rep.structure)\nprint(\"Permuted Text Representations:\")\nprint(text_rep.get_requested_text_reps(text_representations_requested))\n</code></pre>"},{"location":"usage/#translate-structure","title":"Translate Structure","text":"<p>The <code>translate_structure</code> transformation randomly translates all atoms in a structure by a specified vector. This can simulate small displacements in the structure.</p> <pre><code>transformations = [(\"translate_structure\", {\"seed\": 42, \"vector\": [0.1, 0.1, 0.1]})]\n\ntext_rep = TextRep.from_input(structure_1, transformations)\ntext_representations_requested = [\"crystal_llm_rep\"]\nprint(\"Translated Crystal-text-LLM Representations:\")\nprint(text_rep.get_requested_text_reps(text_representations_requested))\n</code></pre>"},{"location":"usage/#augmentating-data","title":"Augmentating data","text":"<p>In principle, we can generate valid text representations with random transformations with physically meaningful parameters. Dummy example is shown below</p> <pre><code>from xtal2txt.core import TextRep\n\n# Define transformations\ntranslation_vectors = np.random.uniform(low=0.1, high=0.5, size=(3, 3))\nfor vector in translation_vectors:\n    transformations = [\n        (\"permute_structure\", {\"seed\": 42}),\n        (\"perturb_structure\", {\"seed\": 42, \"max_distance\": 0.1}),\n        (\"translate_structure\", {\"seed\": 42, \"vector\": vector.tolist()})\n    ]\n    text_rep = TextRep.from_input(structure_2, transformations)\n    text_representations_requested = [\"crystal_llm_rep\"]\n    print(\"Translated Text Representations:\")\n    print(text_rep.get_requested_text_reps(text_representations_requested))\n</code></pre>"},{"location":"usage/#output","title":"output","text":"<pre><code>Translated Text Representations:\n{'crystal_llm_rep': '3.9 3.9 3.9\\n90 90 90\\nO2-\\n0.76 0.98 0.41\\nTi4+\\n0.77 0.98 0.89\\nO2-\\n0.76 0.49 0.89\\nO2-\\n0.26 0.97 0.88\\nSr2+\\n0.25 0.47 0.38'}\nTranslated Text Representations:\n{'crystal_llm_rep': '3.9 3.9 3.9\\n90 90 90\\nO2-\\n0.85 0.66 0.18\\nTi4+\\n0.86 0.66 0.66\\nO2-\\n0.85 0.17 0.66\\nO2-\\n0.35 0.65 0.65\\nSr2+\\n0.34 0.15 0.15'}\nTranslated Text Representations:\n{'crystal_llm_rep': '3.9 3.9 3.9\\n90 90 90\\nO2-\\n0.63 0.94 0.35\\nTi4+\\n0.64 0.94 0.84\\nO2-\\n0.64 0.45 0.84\\nO2-\\n0.13 0.94 0.83\\nSr2+\\n0.12 0.43 0.33'}\n</code></pre> <p>more examples are available as notebooks in the repository</p> <p>The following transformations are available for transforming structures:</p>"},{"location":"usage/#randomly-permute-structure","title":"Randomly permute structure","text":"<p><code>permute_structure</code> randomly permutes the order of atoms in a structure.</p>"},{"location":"usage/#randomly-translate-single-atom","title":"Randomly translate single atom","text":"<p><code>translate_single_atom</code> randomly translates one or more atoms in a structure.</p>"},{"location":"usage/#randomly-perturb-structure","title":"Randomly perturb structure","text":"<p><code>perturb_structure</code> randomly perturbs atoms in a structure.</p>"},{"location":"usage/#randomly-translate-structure","title":"Randomly translate structure","text":"<p><code>translate_structure</code> randomly translates the atoms in a structure.</p> <p>This transformation supports additional keyword arguments for fine-tuning the translation.  xtal2txt leverage methods from pymatgen and support all the keyword arguments in <code>Structure.translate_sites</code> method.</p> <p>All transformations utilize a common seed value for reproducibility and accept additional parameters for customization.</p> <p>For more details on each transformation and its parameters, refer to the respective function documentation.</p>"},{"location":"usage/#tokenizers","title":"Tokenizers","text":""},{"location":"usage/#using-xtal2txt-tokenizers","title":"Using xtal2Txt tokenizers","text":"<p>By default, the tokenizer is initialized with <code>\\[CLS\\]</code> and <code>\\[SEP\\]</code> tokens. For example</p> <pre><code>from xtal2txt.tokenizer import SliceTokenizer\n\ntokenizer = SliceTokenizer(\n                model_max_length=512,\n                truncation=True,\n                padding=\"max_length\",\n                max_length=512\n            )\nprint(tokenizer.cls_token) # returns [CLS]\n</code></pre> <p>You can access the <code>\\[CLS\\]</code> token using the <code>cls_token</code> attribute of the tokenizer. During decoding, you can utilize the <code>skip_special_tokens</code> parameter to skip these special tokens.</p> <p>Decoding with skipping special tokens:</p> <pre><code>tokenizer.decode(token_ids, skip_special_tokens=True)\n</code></pre>"},{"location":"usage/#initializing-tokenizers-with-custom-special-tokens","title":"Initializing tokenizers with custom special tokens","text":"<p>In scenarios where the <code>\\[CLS\\]</code> token is not required, you can initialize the tokenizer with an empty special_tokens dictionary.</p> <p>Initialization without <code>\\[CLS\\]</code> and <code>\\[SEP\\]</code> Tokens:</p> <pre><code>tokenizer = SliceTokenizer(\n                model_max_length=512,\n                special_tokens={},\n                truncation=True,\n                padding=\"max_length\",\n                max_length=512\n            )\n</code></pre> <p>All <code>Xtal2txtTokenizer</code> instances inherit from {ref}<code>PreTrainedTokenizer &lt;regression_transformer&gt;</code> and accept arguments compatible with the HuggingFace tokenizer.</p>"},{"location":"usage/#tokenizers-with-special-number-tokenization","title":"Tokenizers with special number tokenization","text":"<p>The <code>special_num_token</code> argument (by default <code>False</code>) can be set to true to tokenize numbers in a special way as designed and implemented by {ref}<code>RegressionTransformer &lt;regression_transformer&gt;</code>.</p> <pre><code>tokenizer = SliceTokenizer(\n                special_num_token=True,\n                model_max_length=512,\n                special_tokens={},\n                truncation=True,\n                padding=\"max_length\",\n                max_length=512\n            )\n</code></pre>"}]}